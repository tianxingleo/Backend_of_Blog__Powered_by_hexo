---
title: DUT开发区cpc组第二次例会笔记（2025秋）
date: 2025-10-30 21:21:59
tags:
  - cpc
  - cpp
  - 算法
---

## 1. 二分查找

### 1. 迭代器 (Iterator)



**迭代器**可以被理解为一个“智能指针”或“书签”，它指向容器（如 `vector`, `list`, `set`, `map` 等）中的某个特定元素。

它是 C++ STL（标准模板库）的“胶水”，让算法（如排序、查找）能够与各种不同的数据容器（如数组、链表）协同工作，而不需要关心容器内部是如何存储数据的。

**核心操作：**

- **访问 (`\*`)：** 使用 `*it` 来获取迭代器 `it` 所指向的元素的值。
- **移动 (`++`)：** 使用 `it++` 或 `++it` 将迭代器移动到容器中的**下一个**元素。
- **比较 (`==`, `!=`)：** 比较两个迭代器是否指向同一个位置。

**两个特殊的迭代器：**

- `container.begin()`: 返回一个指向容器**第一个元素**的迭代器。
- `container.end()`: 返回一个指向容器**最后一个元素的“下一个”位置**的迭代器。它是一个“哨兵”，不指向任何有效元素，但它标志着容器的结尾。

> **关键概念：** 算法通常操作一个由两个迭代器定义的“**左闭右开**”区间 `[begin, end)`。它包含 `begin` 指向的元素，但不包含 `end` 指向的元素。

------



### 2. `lower_bound` (下界)



`lower_bound` 用于在**已排序**的序列中进行高效的**二分查找**。

> **⚠️ 前提条件：** `lower_bound` 和 `upper_bound` 都要求它们所操作的区间 `[first, last)` **必须是已排序的**（非递减顺序）。如果数据未排序，结果将是错误的。

功能：

它查找一个值 val，并返回一个迭代器，该迭代器指向区间中第一个“不小于”val（即 大于或等于 $val$）的元素。

**返回值（迭代器）的三种情况：**

1. **找到 `val`：** 返回指向**第一个**等于 `val` 的元素的迭代器。
2. **未找到 `val`，但有更大值：** 返回指向第一个**严格大于** $val$ 的元素的迭代器（这个位置是 `val` 理想的插入位置）。
3. **所有元素都小于 `val`：** 返回 `end()` 迭代器（指向区间的末尾）。

**简单记忆：** `lower_bound` 找到的是 $val$ **“可以插入的第一个位置”**（以保持排序）。

------



### 3. `upper_bound` (上界)



`upper_bound` 同样用于在**已排序**的序列中进行二分查找。

功能：

它查找一个值 val，并返回一个迭代器，该迭代器指向区间中第一个“严格大于”val 的元素。

**返回值（迭代器）的三种情况：**

1. **找到 `val`：** 返回指向**最后一个**等于 `val` 的元素的**“下一个”**位置的迭代器。
2. **未找到 `val`，但有更大值：** 返回指向第一个**严格大于** $val$ 的元素的迭代器（同 `lower_bound` 的情况 2）。
3. **所有元素都小于或等于 `val`：** 返回 `end()` 迭代器。

**简单记忆：** `upper_bound` 找到的是 $val$ **“可以插入的最后一个位置”**（以保持排序）。

------



### 总结对比与示例



假设我们有一个**已排序**的 `vector`：

C++

```cpp
std::vector<int> v = {10, 20, 30, 30, 30, 40, 50};
// 索引:             0   1   2   3   4   5   6
```



#### 示例 1：查找存在的值 `val = 30`



- **`lower_bound(v.begin(), v.end(), 30)`**
  - **含义：** 查找第一个 $\ge 30$ 的元素。
  - **结果：** 指向索引 `2` 的元素（第一个 `30`）。
- **`upper_bound(v.begin(), v.end(), 30)`**
  - **含义：** 查找第一个 $> 30$ 的元素。
  - **结果：** 指向索引 `5` 的元素（`40`）。



#### 示例 2：查找不存在的值 `val = 35`



- **`lower_bound(v.begin(), v.end(), 35)`**
  - **含义：** 查找第一个 $\ge 35$ 的元素。
  - **结果：** 指向索引 `5` 的元素（`40`）。
- **`upper_bound(v.begin(), v.end(), 35)`**
  - **含义：** 查找第一个 $> 35$ 的元素。
  - **结果：** 指向索引 `5` 的元素（`40`）。



#### 示例 3：查找比所有元素都大的值 `val = 60`



- **`lower_bound(v.begin(), v.end(), 60)`**
  - **含义：** 查找第一个 $\ge 60$ 的元素。
  - **结果：** `v.end()` (没有元素 $\ge 60$)。
- **`upper_bound(v.begin(), v.end(), 60)`**
  - **含义：** 查找第一个 $> 60$ 的元素。
  - **结果：** `v.end()` (没有元素 $> 60$)。



### 🚀 实际应用技巧



`lower_bound` 和 `upper_bound` 结合使用非常强大：

**1. 判断元素是否存在 (且高效)**

C++

```cpp
// 在 vector 中查找 30
auto it = std::lower_bound(v.begin(), v.end(), 30);

// 必须检查 it != v.end() (防止越界) 并且 *it == 30 (确保找到的不是比 30 大的数)
if (it != v.end() && *it == 30) {
    // 元素 30 存在
} else {
    // 元素 30 不存在
}
```

**2. 统计等于 `val` 的元素个数**

利用 `upper_bound` 指向最后一个 `val` 的下一个位置，`lower_bound` 指向第一个 `val` 的位置，它们之间的距离就是 `val` 的个数。

C++

```cpp
auto lower = std::lower_bound(v.begin(), v.end(), 30);
auto upper = std::upper_bound(v.begin(), v.end(), 30);

// std::distance 计算两个迭代器之间的距离
int count = std::distance(lower, upper); 
// 在这个例子中，count 会是 3 (因为有三个 30)
```

**3. 在 `set` 和 `map` 中使用**

`std::set` 和 `std::map` 这种**本身就是有序**的容器，它们**自带了** `lower_bound` 和 `upper_bound` 成员函数。

**强烈推荐使用它们自带的成员函数**，因为这比使用全局的 `std::lower_bound` 更快（它们利用自身的树形结构查找，复杂度为 $O(\log N)$，而全局函数在 `vector` 上也是 $O(\log N)$，但在 `list` 上就是 $O(N)$ 了）。

C++

```cpp
std::set<int> s = {10, 20, 30, 40, 50};
auto it = s.lower_bound(30); // 返回指向 30 的迭代器

std::map<int, std::string> m = {{10, "a"}, {20, "b"}, {30, "c"}};
auto map_it = m.lower_bound(25); // 返回指向 {30, "c"} 的迭代器
```

## 2.互质判断算法

在C++中，判断两个数是否互质，常用的方法是通过 **欧几里得算法**（也称为 **辗转相除法**）计算它们的最大公约数（GCD）。如果两个数的最大公约数是1，那么它们就是互质的。

### 欧几里得算法：

*   该算法基于一个基本原理：两个数  $a$  和  $b$  的最大公约数  $\text{gcd}(a, b)$  等于  $\text{gcd}(b, a \% b)$ ，其中  $\% $  表示取余操作。
*   递归或迭代地使用此原理直到其中一个数为0，此时另一个数就是最大公约数。

### 判断互质的算法实现：

```cpp
#include <iostream>
using namespace std;

// 欧几里得算法计算最大公约数
int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;  // 计算余数
        a = temp;
    }
    return a;  // 返回最大公约数
}

// 判断两个数是否互质
bool areCoprime(int a, int b) {
    return gcd(a, b) == 1;
}

int main() {
    int a, b;
    cout << "请输入两个整数: ";
    cin >> a >> b;

    if (areCoprime(a, b)) {
        cout << a << " 和 " << b << " 是互质的。" << endl;
    } else {
        cout << a << " 和 " << b << " 不是互质的。" << endl;
    }

    return 0;
}
```

### 解释：

1.  **`gcd` 函数**：实现了欧几里得算法，递归计算两个数的最大公约数。
2.  **`areCoprime` 函数**：通过调用 `gcd` 函数，检查最大公约数是否为1，若为1则说明这两个数是互质的。
3.  在 `main` 函数中，用户输入两个整数，然后判断它们是否互质。

### 例子：

输入：

```
请输入两个整数: 15 28
```

输出：

```
15 和 28 是互质的。
```

因为15和28的最大公约数是1，所以它们是互质的。
