---
title: 2025学年大一上程序设计基础期末上机考试复习提纲
date: 2025-11-23 14:34:01
tags:
  - c
  - 大学
---

# printf与scanf

### 1. 核心格式控制符 (常用对照表)



这是最基础的对应关系，适用于大多数标准数据类型。

| **数据类型**    | **格式符**  | **printf (输出) 说明**       | **scanf (输入) 说明**                                 |
| --------------- | ----------- | ---------------------------- | ----------------------------------------------------- |
| **整型 (int)**  | `%d`        | 有符号十进制整数             | 输入十进制整数                                        |
|                 | `%i`        | 同 `%d`                      | **区别：** 能自动识别输入格式(如 `0x` 开头按16进制读) |
| **无符号整型**  | `%u`        | 无符号十进制整数             | 仅接受无符号数                                        |
| **八进制**      | `%o`        | 无前缀的八进制               | 输入八进制数                                          |
| **十六进制**    | `%x` / `%X` | 输出小写/大写 (如 `a` / `A`) | 输入十六进制数 (大小写均可)                           |
| **字符 (char)** | `%c`        | 输出单个字符                 | 输入单个字符 (**注意：** 会读取空格或回车)            |
| **字符串**      | `%s`        | 输出字符串                   | 输入字符串 (**注意：** 遇空格、回车即停止)            |
| **浮点型**      | `%f`        | 默认保留6位小数              | **仅用于 `float`**                                    |
| **科学计数法**  | `%e` / `%E` | 指数形式输出                 | 输入科学计数法                                        |
| **指针 (地址)** | `%p`        | 输出地址 (十六进制)          | 输入地址                                              |

### 2. 长度修饰符 (Long/Short 处理)



这是初学者最容易搞混的地方，尤其是 `double` 类型。

| **目标类型**      | **格式符组合** | **关键注意点**                                               |
| ----------------- | -------------- | ------------------------------------------------------------ |
| **long int**      | `%ld`          | 输入输出通用                                                 |
| **long long int** | `%lld`         | 输入输出通用 (C99 标准)                                      |
| **short int**     | `%hd`          | 输出时通常可用 `%d`，但在 `scanf` 中必须用 `%hd` 以防内存越界 |
| **double**        | **`%lf`**      | **这是重点！**   `scanf` 必须用 `%lf`。  `printf` 用 `%f` 或 `%lf` 都可以 (C语言在输出时会自动将 float 提升为 double)。 |
| **long double**   | `%Lf`          | 输入输出通用                                                 |

这是一个非常经典且重要的 C 语言基础问题。`printf`（输出）和 `scanf`（输入）虽然使用相似的格式控制符（`%`），但在细节处理上有几个**致命的区别**。

以下是基于常用场景的分类总结：

------



### 1. 核心格式控制符 (常用对照表)



这是最基础的对应关系，适用于大多数标准数据类型。

| **数据类型**    | **格式符**  | **printf (输出) 说明**       | **scanf (输入) 说明**                                 |
| --------------- | ----------- | ---------------------------- | ----------------------------------------------------- |
| **整型 (int)**  | `%d`        | 有符号十进制整数             | 输入十进制整数                                        |
|                 | `%i`        | 同 `%d`                      | **区别：** 能自动识别输入格式(如 `0x` 开头按16进制读) |
| **无符号整型**  | `%u`        | 无符号十进制整数             | 仅接受无符号数                                        |
| **八进制**      | `%o`        | 无前缀的八进制               | 输入八进制数                                          |
| **十六进制**    | `%x` / `%X` | 输出小写/大写 (如 `a` / `A`) | 输入十六进制数 (大小写均可)                           |
| **字符 (char)** | `%c`        | 输出单个字符                 | 输入单个字符 (**注意：** 会读取空格或回车)            |
| **字符串**      | `%s`        | 输出字符串                   | 输入字符串 (**注意：** 遇空格、回车即停止)            |
| **浮点型**      | `%f`        | 默认保留6位小数              | **仅用于 `float`**                                    |
| **科学计数法**  | `%e` / `%E` | 指数形式输出                 | 输入科学计数法                                        |
| **指针 (地址)** | `%p`        | 输出地址 (十六进制)          | 输入地址                                              |

------



### 2. 长度修饰符 (Long/Short 处理)



这是初学者最容易搞混的地方，尤其是 `double` 类型。

| **目标类型**      | **格式符组合** | **关键注意点**                                               |
| ----------------- | -------------- | ------------------------------------------------------------ |
| **long int**      | `%ld`          | 输入输出通用                                                 |
| **long long int** | `%lld`         | 输入输出通用 (C99 标准)                                      |
| **short int**     | `%hd`          | 输出时通常可用 `%d`，但在 `scanf` 中必须用 `%hd` 以防内存越界 |
| **double**        | **`%lf`**      | **这是重点！**   `scanf` 必须用 `%lf`。  `printf` 用 `%f` 或 `%lf` 都可以 (C语言在输出时会自动将 float 提升为 double)。 |
| **long double**   | `%Lf`          | 输入输出通用                                                 |

------



### 3. `printf` 特有的格式化输出 (美化)



`scanf` 很少使用这些修饰符，它们主要用于控制 `printf` 的输出样式。

- **指定宽度 (`%md`)**：
  - `%5d`: 至少占用5个字符宽度，**右对齐**（左补空格）。
  - `%-5d`: 至少占用5个字符宽度，**左对齐**（右补空格）。
  - `%05d`: 至少占用5个字符宽度，不足的前面**补0** (常用于日期/时间，如 `2025-01-05`)。
- **指定精度 (`%.nf`)**：
  - `%.2f`: 保留小数点后 2 位（四舍五入）。
  - `%.*f`: 动态指定精度（需要两个参数，如 `printf("%.*f", 2, 3.14159)` 输出 `3.14`）。
- **显示正负号 (`%+d`)**：
  - 强制显示正数的 `+` 号。

# 头文件

### 1. `<stdio.h>` —— 只要写代码就得用



**全称：** Standard Input Output (标准输入输出) **地位：** C 语言的“氧气”，几乎所有程序都需要。

- **核心功能：** 负责屏幕输出、键盘输入、文件读写。
- **常用函数：**
  - `printf()`：格式化输出。
  - `scanf()`：格式化输入。
  - `getchar()` / `putchar()`：读/写单个字符。
  - `fopen()` / `fclose()`：打开/关闭文件（进阶）。



### 2. `<stdlib.h>` —— 万能工具箱



**全称：** Standard Library (标准库) **地位：** 杂项大管家，包含内存管理、类型转换、随机数等。

- **核心功能：** 动态内存分配、字符串转数字、随机数生成、程序控制。
- **常用函数：**
  - `malloc()` / `free()`：**非常重要**，动态分配和释放内存。
  - `atoi()` / `atof()`：把字符串转成整数/浮点数 (ASCII to Integer/Float)。
  - `rand()` / `srand()`：生成随机数。
  - `system("pause")`：暂停窗口（Windows常见）。
  - `exit()`：直接结束程序。



### 3. `<string.h>` —— 字符串处理专家



**地位：** C 语言中字符串不是一种原生类型（而是字符数组），处理起来很麻烦，必须依赖这个库。

- **核心功能：** 复制、拼接、比较、测量字符串。
- **常用函数：**
  - `strlen()`：计算字符串长度（不包含结束符 `\0`）。
  - `strcpy()`：复制字符串（注意目标数组要够大）。
  - `strcat()`：拼接字符串。
  - `strcmp()`：比较两个字符串的内容（相等返回0）。
  - `memset()` / `memcpy()`：直接对内存块进行设置或拷贝（高效，常用于数组清零）。



### 4. `<math.h>` —— 数学计算器



**地位：** 进行复杂数学运算时使用。

- **核心功能：** 幂运算、开方、三角函数、取整。
- **常用函数：**
  - `pow(x, y)`：计算 x 的 y 次幂。
  - `sqrt(x)`：计算开平方。
  - `fabs(x)`：计算浮点数的绝对值（整数绝对值用 `abs`，在 `<stdlib.h>` 中）。
  - `ceil()` / `floor()`：向上/向下取整。
  - **注意：** 在 Linux (gcc) 环境下编译时，可能需要加 `-lm` 参数链接数学库。



### 5. `<ctype.h>` —— 字符类型的“安检员”



**地位：** 用来判断一个字符是字母、数字还是空格，或者进行大小写转换。

- **核心功能：** 字符分类测试、大小写转换。
- **常用函数：**
  - `isdigit(c)`：判断是不是数字字符 ('0'-'9')。
  - `isalpha(c)`：判断是不是字母。
  - `islower()` / `isupper()`：判断大小写。
  - `toupper()` / `tolower()`：将字符转换为大写/小写。



### 6. `<stdbool.h>` —— 布尔类型 (C99 标准)



**地位：** 让 C 语言像 C++/Java 一样支持 `true` 和 `false`。

- **背景：** 早期 C 语言没有 `bool` 类型，通常用 `int` 的 0 和 1 代替。

- **功能：** 引入 `bool` 类型以及 `true` / `false` 宏。

- **用法：**

  C

  ```
  #include <stdbool.h>
  bool is_pass = true; // 如果不引头文件，必须写 int is_pass = 1;
  ```

------



### 进阶一点点 (常用于大作业)



- **`<time.h>`**：处理时间，最常用的是 `time(NULL)` 配合 `srand()` 来生成**真正的随机数**。
- **`<limits.h>`**：查看数据类型的极限值，比如 `INT_MAX` (int 能存的最大值)。



# 随机数

**代码示例：**

```c
#include <stdio.h>
#include <stdlib.h> // 包含 rand() 和 srand()
#include <time.h>   // 包含 time()

int main() {
    // 1. 初始化种子 (只需在 main 开头写一次，千万别放在循环里！)
    srand(time(0));

    // 2. 生成随机数
    int r = rand(); 
    
    // 如果需要 0 到 99 之间的数：
    int r_range = rand() % 100;

    printf("随机数: %d\n", r);
    printf("0-99之间: %d\n", r_range);

    return 0;
}
```



# C中的四舍五入

### 1. 什么时候是“自动”四舍五入？



严格来说，C 语言在**数值计算**逻辑中，**永远不会**自动四舍五入。

唯一看起来像“自动四舍五入”的情况，发生在 **`printf` 格式化输出** 时。

- **场景**：当你只想**看**结果，而不改变变量本身的值时。
- **原理**：`printf` 的 `%.nf` 格式符在显示时，会对第 $n+1$ 位小数进行四舍五入，然后显示前 $n$ 位。

**示例代码：**

C

```
#include <stdio.h>

int main() {
    double money = 3.568;
    
    // 仅仅是显示变了，内存里的 money 依然是 3.568
    printf("%.2f", money); // 输出 3.57 (自动进位了)
    printf("%.1f", money); // 输出 3.6
    
    return 0;
}
```

------



### 2. 什么时候是“自动截断”（也就是不四舍五入）？



这是新手最容易踩的坑。在以下两种情况中，C 语言会**直接丢弃小数部分**：

1. **强制类型转换（Float 转 Int）**：

   C

   ```
   double a = 3.99;
   int b = (int)a; // b 的值是 3，而不是 4！
   ```

2. **整数除法**：

   C

   ```
   int result = 5 / 2; // 结果是 2，而不是 2.5 或 3
   ```

------



### 3. 怎么“手动”四舍五入？



如果你需要计算出一个整数结果存起来，并且要求四舍五入，必须自己写代码实现。这里有两种主流方法：



#### 方法一：经典算法 `+0.5` （最常用、最高效）



这是 C 语言程序员必须掌握的“土办法”。

原理：

- 如果小数部分 $< 0.5$（例如 0.4），加上 0.5 后整数部分不变（$0.4+0.5=0.9$），截断后还是原数。
- 如果小数部分 $\ge 0.5$（例如 0.6），加上 0.5 后整数部分会加 1（$0.6+0.5=1.1$），截断后就实现了进位。

公式：



$$result = (int)(x + 0.5)$$

**代码示例**：

C

```c
#include <stdio.h>

int main() {
    double a = 3.1;
    double b = 3.6;

    // 手动四舍五入
    int round_a = (int)(a + 0.5); // (int)(3.6) -> 3
    int round_b = (int)(b + 0.5); // (int)(4.1) -> 4

    printf("3.1 -> %d\n", round_a);
    printf("3.6 -> %d\n", round_b);

    return 0;
}
```

*注意：如果是负数，这个公式需要微调为 `(int)(x - 0.5)`。*



#### 方法二：使用库函数 `round()` （最标准）



如果不喜欢写数学公式，可以使用 `<math.h>` 里的标准函数。

**代码示例**：

C

```c
#include <stdio.h>
#include <math.h> // 必须引入这个头文件

int main() {
    double x = 3.6;
    double y = 3.4;

    // round() 返回的还是 double 类型，通常需要强转回 int
    int r1 = (int)round(x); 
    int r2 = (int)round(y);

    printf("%d, %d", r1, r2); // 输出 4, 3
    return 0;
}
```



# 冒泡排序与选择排序

### 1. 冒泡排序 (Bubble Sort)



**核心思想：** 像水里的气泡一样，轻的往上浮，重的往下沉。 **操作方式：** **两两比较，位置不对就交换。** 每一轮循环结束后，最大的那个数会被“顶”到数组的最右边。



#### 算法步骤：



1. 从第一个元素开始，和它的邻居（下一个元素）比较。
2. 如果左边比右边大，就**交换**它们。
3. 继续比较下一对邻居，直到比到数组末尾。此时，最大的数已经到了最后。
4. 重复以上步骤，但下一轮不用再比最后一个数了（因为它已经是最大的了）。



#### 代码实现：



C

```c
#include <stdio.h>

void bubble_sort(int arr[], int n) {
    // 外层循环：控制比较的轮数，一共需要 n-1 轮
    for (int i = 0; i < n - 1; i++) {
        
        // 内层循环：负责具体的比较和交换
        // 注意：j < n - 1 - i，因为每过一轮，最后 i 个元素就已经排好了，不用再比
        for (int j = 0; j < n - 1 - i; j++) {
            
            // 如果前一个比后一个大，就交换（升序）
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = 7;
    bubble_sort(arr, n);
    
    for(int i=0; i<n; i++) printf("%d ", arr[i]);
    return 0;
}
```

------



### 2. 选择排序 (Selection Sort)



**核心思想：** 全局扫描，**只找最小的**（或最大的），找到了再换。 **操作方式：** 每一轮都在剩下的乱序堆里找到**最小值**的索引，然后把它和乱序堆的第一个位置**交换**。



#### 算法步骤：



1. 假设当前乱序部分的第一个元素是“最小的”（记录它的下标）。
2. 用它去跟后面所有的数比，如果发现更小的，就更新“最小下标”。
3. 扫描完一整轮后，将真正的最小值与乱序部分的第一个元素交换。
4. 乱序部分的起点向后移一位，重复。



#### 代码实现：



C

```c
#include <stdio.h>

void selection_sort(int arr[], int n) {
    // 外层循环：决定当前要填坑的位置 (i)
    for (int i = 0; i < n - 1; i++) {
        
        // 1. 先假设当前位置 i 就是最小值的下标
        int min_idx = i;
        
        // 2. 内层循环：去后面找有没有比 arr[min_idx] 更小的
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[min_idx]) {
                min_idx = j; // 只要记录下标，不要急着交换！
            }
        }
        
        // 3. 找到真正的最小值后，才做一次交换
        // (如果 min_idx 没变，说明 i 本来就是最小的，不用换)
        if (min_idx != i) {
            int temp = arr[i];
            arr[i] = arr[min_idx];
            arr[min_idx] = temp;
        }
    }
}
```



# 线性搜索与二分查找

### 1. 线性搜索 (Linear Search) —— 简单粗暴



核心思想： 从头到尾一个一个看。

就像你在家里找钥匙，把每个抽屉都拉开看一遍，直到找到或者全找完了也没找到。

- **前提条件：** 无（数组可以是乱序的，也可以是有序的）。
- **效率：** 慢。时间复杂度为 $O(N)$。如果数组有 100 万个数，最坏情况要找 100 万次。



#### 代码实现



C

```
#include <stdio.h>

// 返回找到的下标，没找到返回 -1
int linear_search(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i; // 找到了，直接返回位置
        }
    }
    return -1; // 循环结束还没找到
}

int main() {
    int arr[] = {10, 50, 30, 70, 80, 20};
    int idx = linear_search(arr, 6, 30);
    if (idx != -1) printf("找到了，下标是: %d\n", idx);
    else printf("没找到\n");
    return 0;
}
```

------



### 2. 二分查找 (Binary Search) —— 极速折半



核心思想： 每次都砍掉一半。

就像查英文字典查单词 "Math"，你不会从第一页开始翻。你会直接翻到中间，发现是 "L"，因为 M 在 L 后面，所以前面的半本字典直接扔掉不看，只在后半本里找。

- **前提条件：** **数组必须已经排好序（升序或降序）**。这是硬性要求！
- **效率：** 极快。时间复杂度为 $O(\log N)$。
  - 找 100 万个数，线性搜索要找 100 万次，二分查找最多只需找 **20次** ($2^{20} \approx 100\text{万}$)。



#### 算法步骤



1. 定义左边界 `left` 和右边界 `right`。
2. 计算中间位置 `mid`。
3. 如果 `arr[mid]` 就是要找的数 -> 结束。
4. 如果 `arr[mid]` 比目标小 -> 说明目标在右边，把 `left` 移到 `mid + 1`。
5. 如果 `arr[mid]` 比目标大 -> 说明目标在左边，把 `right` 移到 `mid - 1`。
6. 只要 `left <= right` 就重复上述步骤。



#### 代码实现



C

```c
#include <stdio.h>

// 前提：arr 必须是排好序的
int binary_search(int arr[], int n, int target) {
    int left = 0;
    int right = n - 1;
    
    while (left <= right) { // 注意：这里要有等号，防止漏掉最后一个元素
        int mid = (left + right) / 2;
        
        if (arr[mid] == target) {
            return mid; // 找到了
        } 
        else if (arr[mid] < target) {
            left = mid + 1; // 目标在右半区，抛弃左边
        } 
        else {
            right = mid - 1; // 目标在左半区，抛弃右边
        }
    }
    
    return -1; // 没找到
}

int main() {
    // 数组必须是有序的！
    int arr[] = {10, 20, 30, 40, 50, 60, 70, 80, 90}; 
    int idx = binary_search(arr, 9, 30);
    
    if (idx != -1) printf("找到了，下标是: %d\n", idx);
    else printf("没找到\n");
    return 0;
}
```



# switch

### 基本语法结构

```c
switch (表达式) {
    case 常量1:
        // 如果表达式的值等于常量1，执行这里的代码
        break; // ❗重要：跳出 switch，不然会继续往下执行！

    case 常量2:
        // 如果表达式的值等于常量2，执行这里
        break;

    // 可以有任意多个 case ...

    default:
        // 如果上面所有的 case 都不匹配，就执行这里（相当于 else）
        break;
}
```



# 函数与二维数组

### 方法一：固定列宽（最传统、最通用）



这是 C 语言教科书里最常见的写法。 **规则**：函数声明时，第一维（行数）可以省略，但**第二维（列数）必须写死**。

- **语法**：`void func(int arr[][列数], int 行数)`
- **优点**：简单，所有编译器都支持。
- **缺点**：不够灵活，函数只能处理特定列宽的数组（比如只能处理 5 列的，不能处理 6 列的）。

**代码示例：**

C

```c
#include <stdio.h>

#define COLS 4 // 定义固定的列数

// 接收函数：注意 [4] 不能省，[] 可以省
void printArray(int arr[][COLS], int rows) {
    printf("--- 开始打印 ---\n");
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < COLS; j++) {
            // 操作方法：直接像在 main 里一样用 arr[i][j]
            printf("%d ", arr[i][j]);
            
            // 修改数组：会直接影响原数组
            arr[i][j] += 1; 
        }
        printf("\n");
    }
}

int main() {
    int matrix[3][COLS] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };

    // 传递时：只需要传数组名
    printArray(matrix, 3);
    
    return 0;
}
```

------



### 方法二：变长数组 VLA（C99 标准，最推荐）



如果你使用的是现代编译器（GCC, Clang, VS2019+），可以使用 C99 标准引入的**变长数组（Variable Length Arrays）**。

**规则**：把行数和列数作为参数传进去，用它们来定义数组维度。 **注意**：参数顺序很重要！**维度的变量必须在数组参数之前声明**。

- **语法**：`void func(int rows, int cols, int arr[rows][cols])`
- **优点**：非常灵活，一个函数可以处理任意大小的二维数组。

**代码示例：**

C

```c
#include <stdio.h>

// 这里的 rows 和 cols 必须写在 arr 前面！
void processMatrix(int rows, int cols, int arr[rows][cols]) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            arr[i][j] *= 2; // 将所有元素翻倍
        }
    }
}

int main() {
    int small[2][2] = {{1, 1}, {2, 2}};
    int big[3][4] = {{1,2,3,4}, {5,6,7,8}, {9,10,11,12}};

    // 同一个函数，既能处理 2x2，也能处理 3x4
    processMatrix(2, 2, small);
    processMatrix(3, 4, big);

    printf("Small[0][0] now is: %d\n", small[0][0]); // 输出 2
    return 0;
}
```



# 利用指针交换数

### 第一步：用指针交换两个变量



我们需要定义一个接收**地址**的函数。

- **`int \*p`**：表示这是一个指针变量，用来存地址。
- **`\*p`**（在函数内部）：**解引用**，表示“拿到这个地址里的值”。

C

```
#include <stdio.h>

// 这里的参数必须是指针类型，用来接收地址
void swap(int *p1, int *p2) {
    // 1. 先把 p1 指向的那个数（家里的电视）存到临时变量里
    int temp = *p1;
    
    // 2. 把 p2 指向的数（家里的冰箱）搬到 p1 指向的位置
    *p1 = *p2;
    
    // 3. 把临时变量里的数（电视）搬到 p2 指向的位置
    *p2 = temp;
}

int main() {
    int a = 10;
    int b = 20;

    printf("交换前: a=%d, b=%d\n", a, b);

    // 关键：调用时必须加 & (取地址符)，把钥匙交给函数
    swap(&a, &b);

    printf("交换后: a=%d, b=%d\n", a, b); // 真的变了！
    return 0;
}
```

------



### 3. 第二步：用指针交换数组中的两个元素



其实，交换数组元素和交换普通变量**没有任何区别**。 因为 `arr[i]` 本质上就是一个 `int` 类型的变量，它也有地址，地址就是 `&arr[i]`。

我们直接复用上面的 `swap` 函数即可。

C

```c
#include <stdio.h>

// 还是刚才那个函数，完全不用改
void swap(int *p1, int *p2) {
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    
    printf("交换前: %d %d\n", arr[0], arr[4]); // 输出 1 5

    // 我们要交换第1个(arr[0]) 和 第5个(arr[4])
    // 只需要把它们的地址传进去
    swap(&arr[0], &arr[4]);

    printf("交换后: %d %d\n", arr[0], arr[4]); // 输出 5 1
    
    return 0;
}
```



# 字符串

### 第一部分：`<string.h>` 中的核心函数



记住一点：所有这些函数的工作原理都是**“从头开始往后数，直到遇到 `\0` (结束符) 为止”**。



#### 1. `strlen` - 测量长度



- **全称**：String Length
- **功能**：计算字符串的有效长度（**不包含**最后的 `\0`）。
- **注意**：`sizeof` 算的是内存占用的总大小，`strlen` 算的是里面装了多少字。

C

```c
char str[100] = "hello";
int len = strlen(str); // 结果是 5
int size = sizeof(str); // 结果是 100 (整个数组的大小)
```



#### 2. `strcpy` - 字符串复制



- **全称**：String Copy
- **原型**：`strcpy(目标, 源)`
- **功能**：把后面的字符串赋值给前面的。相当于 `dest = src`（但数组不能直接用 `=` 赋值，所以必须用这个）。
- **致命陷阱**：**目标数组必须足够大**！否则会发生“缓冲区溢出”，导致程序崩溃。

C

```c
char src[] = "Apple";
char dest[10]; 
strcpy(dest, src); // 把 Apple 也就是 'A','p','p','l','e','\0' 拷贝过去
```



#### 3. `strcat` - 字符串拼接



- **全称**：String Concatenate
- **原型**：`strcat(目标, 源)`
- **功能**：把 `src` 拼接到 `dest` 的屁股后面。
- **注意**：`dest` 必须要有足够的剩余空间来容纳拼进来的新内容。

C

```c
char dest[20] = "Hello";
char src[] = " World";
strcat(dest, src); // dest 变成了 "Hello World"
```



#### 4. `strcmp` - 字符串比较



- **全称**：String Compare
- **原型**：`strcmp(字符串1, 字符串2)`
- **功能**：比较两个字符串的内容。**千万不要用 `==` 来比较字符串！**（`==` 比的是地址）。
- **返回值**：
  - **0**：两个字符串**相等**。
  - **负数** (`< 0`)：字符串1 在字典序上排在 字符串2 **前面** (如 "Apple" vs "Banana")。
  - **正数** (`> 0`)：字符串1 在字典序上排在 字符串2 **后面**。

C

```c
if (strcmp(password, "123456") == 0) {
    printf("密码正确");
}
```

------



### 第二部分：C 语言中字符串如何传给函数



在 C 语言中，字符串就是字符数组。当你把数组传给函数时，**它会退化成指针**。

所以，函数接收字符串的参数类型通常是：**`char \*`**。



#### 场景一：只读模式（不修改字符串内容）



如果你只是想把字符串传进去打印、计算长度或者查找，**强烈建议加上 `const`**。这是一种良好的编程习惯，告诉调用者：“放心传进来，我只看，不改。”

- **写法**：`void func(const char *str)`

C

```c
#include <stdio.h>
#include <string.h>

// 这是一个只读函数
void print_info(const char *str) {
    // str[0] = 'A'; // ❌ 报错！不能修改 const 指针指向的内容
    printf("内容: %s, 长度: %d\n", str, strlen(str));
}
```



#### 场景二：读写模式（需要修改字符串内容）



如果你需要在函数里把字符串变大写、替换字符或者拼接内容，就不能加 `const`。

- **写法**：`void func(char *str)` 或者 `void func(char str[])` (两者等价)。

C

```c
#include <stdio.h>
#include <ctype.h> // 用到了 toupper

// 这是一个修改函数：把字符串变成大写
void to_upper_case(char *str) {
    // 这里 str 就是一个指针，指向外部传进来的数组
    for (int i = 0; str[i] != '\0'; i++) {
        if (str[i] >= 'a' && str[i] <= 'z') {
            str[i] = str[i] - 32; // 或者用 toupper(str[i])
        }
    }
}

int main() {
    char my_text[] = "hello"; // ✅ 必须定义成数组，内容存在栈上，可修改
    
    to_upper_case(my_text);
    printf("%s\n", my_text); // 输出 HELLO
    
    return 0;
}
```



### ⚡️ 一个新手必挂的“坑”



在传参修改时，**实参必须是字符数组，不能是字符串字面量（指针）**。

请看这个经典错误：

C

```c
int main() {
    // 写法 A：字符数组
    char str1[] = "hello"; 
    to_upper_case(str1); // ✅ 正确。str1 在栈内存，可以改。

    // 写法 B：字符串指针（指向常量区）
    char *str2 = "hello"; 
    to_upper_case(str2); // ❌ 崩溃！(Segmentation Fault)
    // 原因："hello" 存储在常量区（只读区域），你试图在函数里修改它，程序会直接被操作系统杀掉。
    
    return 0;
}
```



# 结构体初识

### 1. 结构体的核心特点 (Features)



你可以把结构体想象成一张**“简历表”**或**“档案卡”**。 一个学生的信息包含：姓名（字符串）、年龄（整数）、成绩（浮点数）。如果用数组存，你需要三个不同的数组，管理起来很乱。结构体允许你定义一个叫 `Student` 的新类型，把这些都装进去。

- **自定义类型**：它赋予了你创造新数据类型的能力。
- **聚合不同类型**：内部成员（Member）可以是 `int`, `char`, `double`，甚至是指针或另一个结构体。

------



### 2. 声明结构体的方式



通常放在 `main` 函数外面（全局位置），相当于画了一张“图纸”。



#### 方式 A：标准声明 (最常用)



C

```
struct Student {
    char name[20];  // 姓名
    int age;        // 年龄
    double score;   // 分数
}; // ⚠️ 千万别忘了这个分号！
```



#### 方式 B：配合 typedef (老手推荐)



为了偷懒，不用每次都写 `struct` 关键字，可以起个别名。

C

```
typedef struct {
    char name[20];
    int age;
    double score;
} Student; // 这里的 Student 是类型别名，不是变量名
```

------



### 3. 变量与数组的定义、初始化与使用



有了图纸，我们就可以盖房子（定义变量）了。



#### 定义与初始化



C

```
#include <stdio.h>
#include <string.h>

struct Student {
    char name[20];
    int age;
    double score;
};

int main() {
    // 1. 定义单个变量并初始化
    // 就像 int a = 10; 一样简单，用 {} 包裹数据
    struct Student s1 = {"ZhangSan", 19, 95.5};

    // 2. 定义结构体数组 (一个班级的学生)
    struct Student class_A[3] = {
        {"LiSi", 18, 88.0},
        {"WangWu", 20, 92.5},
        {"ZhaoLiu", 19, 85.0}
    };

    return 0;
}
```



#### 如何使用（读写数据）



核心符号是 **点号 `.`** 。读作“的”。

C

```
    // 读取
    printf("姓名: %s, 分数: %.1f\n", s1.name, s1.score);

    // 修改 (写入)
    s1.age = 20;         // 整数直接赋值
    s1.score = 98.0;     // 浮点数直接赋值
    
    // ⚠️ 重点坑：字符串数组不能直接用 = 赋值！
    // s1.name = "NewName"; // ❌ 错误！
    strcpy(s1.name, "NewName"); // ✅ 正确，必须用 strcpy
```

------



### 4. 结构体指针 (Structure Pointer)



这是数据结构（链表、树）的基础。 当有一个指针指向结构体时，访问成员的方式变了。

- 普通变量用 **`.`** (点)
- 指针变量用 **`->`** (箭头)

C

```
    struct Student s1 = {"Tom", 18, 90.0};
    struct Student *p = &s1; // p 指向 s1 的地址

    // 方式 1：解引用后用点 (太啰嗦，很少用)
    printf("%s", (*p).name); 

    // 方式 2：使用箭头运算符 (标准写法，必须掌握)
    printf("%s", p->name);   // 读作：p 指向的那个结构体的 name
    p->age = 21;             // 修改
```

**记忆口诀：** 是本体就用点 `.`，是指针就用箭头 `->`。

------



### 5. 向函数传递结构体



有两种方式，其中的区别决定了程序的效率和功能。



#### 方式 A：值传递 (Pass by Value) —— 复制一份



把整个结构体的内容拷贝一份给函数。

- **优点**：安全，函数里乱改也不会影响外面的原变量。
- **缺点**：**效率极低**！如果结构体很大（比如包含大数组），拷贝非常耗时且占内存。
- **功能**：只能读取，无法修改原数据。

C

```
void print_student(struct Student s) {
    // s 是 s1 的复制品
    printf("%s\n", s.name);
}
// 调用：print_student(s1);
```



#### 方式 B：地址传递 (Pass by Pointer) —— 传递钥匙 (推荐)



只传递结构体的地址（指针）。

- **优点**：**极快**（只传 8 字节的地址），不占内存。
- **缺点**：不安全（函数能修改原数据），通常配合 `const` 保护。
- **功能**：既可以读取，也可以修改原数据。

C

```c
// 场景 1：只读 (加 const 防止误改)
void print_student_fast(const struct Student *s) {
    // s 是指针，必须用 ->
    printf("Name: %s\n", s->name); 
    // s->age = 20; // ❌ 报错，const 禁止修改
}

// 场景 2：需要修改
void modify_score(struct Student *s, double new_score) {
    s->score = new_score; // 直接修改了外面的数据
}

// 调用：modify_score(&s1, 100.0); // 记得加 & 取地址
```



# 结构体再识

### 第一部分：结构体的专有名词辨析



在讨论复杂问题前，必须先统一“口径”，否则容易晕。

C

```
// 1. 结构体标签 (Tag)
struct Student {
    // 2. 成员 (Member)
    char name[20];
    int age;
} s1, s2; // 3. 变量 (Variable) / 实例 (Instance)
```

1. **结构体标签 (Tag)**：`Student`。它只是个名字，代表这种“图纸”叫什么。
2. **成员 (Member)**：`name`, `age`。图纸里的具体属性。
3. **变量 (Variable)**：`s1`, `s2`。根据图纸造出来的真正的“人”。
4. **类型 (Type)**：在 C 语言中，完整的类型名是 `struct Student`（两个词合在一起才是类型）。

------



### 第二部分：定义时的两个疑问





#### Q1: 能不能在声明结构体的时候就定义变量？



**答案：可以。** 这是“顺便造人”的写法。

C

```
struct Point {
    int x;
    int y;
} p1, p2, arr[10]; // 声明完图纸，顺便造了 p1, p2 和一个数组
```

- **评价**：这种写法在小程序里很常见，但为了代码清晰，通常建议把定义变量和声明类型分开写。



#### Q2: 能不能不写 `struct` 只写 `Student`？



**答案：默认不行，除非使用 `typedef`。**

在 C++ 中可以直接写 `Student s1;`，但在 **C 语言** 中，必须写全称 `struct Student s1;`。 如果你想偷懒（只写 `Student`），必须给类型起个**别名**。

**写法 A：分步写 (最清晰)**

C

```
struct Student { int age; };  // 声明类型
typedef struct Student Student; // 给 "struct Student" 起个别名叫 "Student"

// 现在可以了：
Student s1; 
```

**写法 B：一步到位 (最常用)**

C

```
typedef struct Student {  // 这里的 Student 是标签
    int age;
} Student; // 这里的 Student 是别名

// 用法：
Student s1;         // ✅ 可以 (用了别名)
struct Student s2;  // ✅ 可以 (用了原名)
```

**写法 C：匿名结构体 (比较懒)**

C

```
typedef struct {  // 省略了标签
    int age;
} Student; 

// 用法：
Student s1;         // ✅ 可以
// struct Student s2; // ❌ 报错！因为根本没有 Student 这个标签
```

------



### 第三部分：多级结构体 (Nested Structure)



**多级结构体**就是“套娃”：一个结构体里面包含另一个结构体变量。

**场景**：一个学生 (`Student`) 有一个生日，生日本身也是个结构体 (`Date`)。

C

```
typedef struct {
    int year;
    int month;
    int day;
} Date;

typedef struct {
    char name[20];
    Date birthday; // ❌ 它是 Date 类型的变量 (不是指针)
    int id;
} Student;
```

**如何访问？** 像剥洋葱一样，一层一层用 **点号 `.`** 剥开。

C

```
Student s1;
s1.id = 1001;
// 访问里面的结构体成员
s1.birthday.year = 2005; 
s1.birthday.month = 11;
```

------



### 第四部分：多级指针与箭头 `->` 的终极逻辑



这是最容易晕的地方：什么时候用点 `.`，什么时候用箭头 `->`？

**核心法则（请背诵）：**

> **看符号左边的东西是什么？**
>
> - 如果是 **实体 (变量/对象)** -> 用 **点 `.`**
> - 如果是 **指针 (地址)** -> 用 **箭头 `->`**



#### 情况 1：最外层是指针，里面是实体



C

```
Student s1;
Student *p = &s1; // p 是指向 Student 的指针

// p 是指针 -> 用箭头
// p->birthday 是实体 (Date 类型变量) -> 用点
p->birthday.year = 2005; 
```



#### 情况 2：里面也是指针 (链表常用)



假设学生手里拿着一本书，书是通过指针记录的。

C

```
typedef struct {
    char title[50];
} Book;

typedef struct {
    char name[20];
    Book *myBook; // ⚠️ 注意：这是个指针！
} Student;

int main() {
    Book b1 = {"C Language"};
    Student s1;
    
    s1.myBook = &b1; // 让 s1 的指针指向 b1
    
    // 1. s1 是实体 -> 用点
    // 2. s1.myBook 是指针 -> 用箭头
    printf("%s", s1.myBook->title); 
    
    return 0;
}
```



#### 情况 3：里外全是指针 (多级指针)



C

```c
    Student s1;
    Book b1 = {"C Language"};
    s1.myBook = &b1;

    Student *ptr = &s1; // ptr 是指向 Student 的指针

    // 1. ptr 是指针 -> 用箭头 (变成 s1 实体)
    // 2. ptr->myBook 是指针 -> 用箭头 (变成 b1 实体)
    // 3. title 是数组(实体) -> 直接访问
    printf("%s", ptr->myBook->title);
```
