---
title: 校园跑脚本开发日志
date: 2025-11-16 15:28:54
tags:
  - python
  - gemini
---

# 校园跑模拟器 (school-runing-dut) 开发历程

## 项目地址

- **GitHub**: [https://github.com/tianxingleo/school-runing-dut](https://www.google.com/url?sa=E&source=gmail&q=https://github.com/tianxingleo/school-runing-dut)

## 序章：程序设计目的与思路

### 1. 项目目的

本项目立项的初衷非常明确：为**大连理工大学开发区校区**的“校园跑”活动提供一个自动化工具。目标是在PC上运行一个安卓模拟器（雷电模拟器），通过脚本自动模拟一个**可靠且拟人化的**操场跑步轨迹，以供 Keep 等运动软件记录。

### 2. 核心思路

最初的构想是，创建一个简单的 Python 脚本，它能读取用户输入的4个操场角点坐标，计算出一个标准400米跑道的完整路径点，然后将这些坐标点“喂”给模拟器。

我们的核心设计思路最终确定为：

- **图形界面 (GUI)**：使用 Python **内置的 `tkinter` 库** 构建一个用户友好的图形界面，用于承载所有的参数设置。
- **多线程架构**：GUI 运行在**主线程**，所有耗时的模拟操作（启动模拟器、计算路径、循环发送命令）必须在一个**单独的工作线程** (`threading.Thread`) 中运行，以防止界面“卡死”。
- **线程通信**：使用 `queue.Queue` 模块，作为工作线程和主GUI线程之间传递状态消息（如“正在模拟...”、“错误”等）的安全通道。
- **外部接口**：通过 `subprocess` 模块调用雷电模拟器官方提供的命令行工具 `dnconsole.exe`，这是与模拟器通信的唯一接口。
- **持久化**：通过 `json` 模块读写 `track_sim_config.json` 文件，自动保存用户的目录、坐标、反作弊参数等设置。

## 第一章：最初的方案与遇到的问题 (GPX 方案)

作为一名开发者，第一反应是寻找最“标准”的解决方案。

1. **方案A：GPX 路径文件**
   - GPX (GPS Exchange Format) 是存储 GPS 轨迹的标准格式。
   - **思路**：写一个 Python 脚本，用 `PySimpleGUI` 做个简单的界面，接收操场的4个角点坐标，用 `geopy` 库计算出几千个路径点，最后用 `gpxpy` 库把它们打包成一个 `my_run.gpx` 文件。
   - **然后呢？** 在模拟器里点击“导入GPX”，开始播放。

这个方案看起来很标准，但我们遇到了第一个阻碍：**雷电模拟器（Leidian Emulator）根本不支持导入 GPX 文件！**

这个看似标准的功能，在雷电模拟器上并不存在。第一个方案，卒。

## 第二章：实时控制的挑战与“静默失败”

我们被迫转向了更复杂的方案：**实时控制**。

这意味着我们的 Python 脚本不能只是个“文件生成器”了，它必须是一个“实时控制器”，在 `while` 循环中，一秒钟几十次地告诉模拟器：“你现在在这里”，“你现在在这里”，“你现在在这里”...

### 2.1 第一次技术迁移：告别 PySimpleGUI

在深入研究之前，我们遇到了第一个阻碍：`PySimpleGUI` 库更改了许可证，现在需要注册才能使用。为了让这个项目保持开源和免配置，我们做出了第一个重要决定：**放弃 `PySimpleGUI`，将整个 GUI 层重写为 Python 内置的 `tkinter` 库。**

虽然 `tkinter` 更“老派”，但它无需安装、100% 免费，是这个项目的最佳选择。

### 2.2 调试过程：寻找“正确”的命令

我们手持 `tkinter` 界面，面对的第一个问题是：“我该如何用代码告诉模拟器我的位置？”

#### 阶段 1：`ldconsole modify --gps` (失败)

这是最显而易见的命令。我们尝试了，脚本开始循环，控制台没有报错。

**但是，模拟器里的位置纹丝不动。**

#### 阶段 2：`adb` 广播 (失败)

我们猜测 `ldconsole` 的命令太“上层”了。我们转向了更底层的 `adb` (Android Debug Bridge)。我们尝试了 `adb broadcast`，向模拟器系统广播一个“设置位置”的意图。

**结果：依旧是“静默失败”。**

#### 阶段 3：反作弊猜想

此时，我们意识到一个关键问题：**我们的敌人可能不是模拟器，而是 Keep 这类 APP 本身。**

APP 非常智能，它会进行**反作弊**检测。如果它发现你的 GPS 在以 10km/h 移动，但你的手机**加速度计**和**计步器**传感器数据为 0（静止），它就会判定 GPS 数据为假，并**忽略**它。

这完美解释了“静默失败”——我们的脚本成功发送了命令，但 APP 拒绝了这些数据。

于是，我们开始尝试“模拟传感器” (`dnconsole sensor`)、“模拟点击” (`adb input swipe`) 等各种底层方法，但都收效甚微。

#### 阶段 4：`telnet` / `socket` (失败)

我们尝试了更古老的 `socket` 方式，试图连接模拟器的 `5554` 控制台端口。

**结果：`[WinError 10061] 目标计算机积极拒绝，无法连接`。**

这个错误反而带来了线索：端口没打开。这引导我们发现，必须从“雷电多开器” (`LDMultiPlayer.exe`) 启动，才能确保服务端口被监听。但即使解决了这个问题，`telnet` 命令 (`emu geo fix`) 也被证明是无效的。

## 第三章：发现官方接口

就在我们几乎要放弃 `ldconsole`，转而去研究第三方 APP（如 `Fake Location`）时，转机来了。

你（项目的使用者/合作者）提供了 `ldconsole.exe help` 的完整输出。

我们一行一行地检查，在列表中发现了一个被忽略的命令：

```
locate <--name mnq_name | --index mnq_idx> --LLI <Lng,Lat>
```

这才是官方的、正确的、用于设置 GPS 的命令。它不是 `modify`，而是 `locate`！

我们立刻重写了工作线程，将所有复杂的 `adb`、`socket` 逻辑全部删除，只保留一行核心命令：

```
subprocess.run([console_exe_path, "locate", "--index", "0", "--LLI", f"{lon},{lat}"])
```

**点击“开始模拟”，程序终于可以正常运行，模拟器中的光标开始移动。**

## 第四章：高级功能与“拟人化” (反作弊算法)

解决了“动”的问题后，我们迎来了新的挑战：如何让它动得“像一个人”？

一个完美的、基于数学计算的轨迹，是反作弊系统最容易识别的特征。我们必须加入“缺陷”和“随机性”，使其更接近真实数据。

### 算法 1：平滑配速 (模拟体力)

**问题**：恒定的 6:00 配速太假了。 **方案**：模拟人类的体力波动。 **实现**：

1. GUI 增加“基础配速”、“变异率 (± min/km)”和“变化平滑度 (秒)”选项。
2. 在工作线程中，不再使用恒定的 `delay`。
3. 它会围绕“基础配速”±“变异率”随机生成一个“目标配速”。
4. 使用指数平滑算法 (`current_pace = current_pace * 0.98 + target_pace * 0.02`)，花费你设定的“平滑度”时间，逐渐将当前配速“平滑”地过渡到目标配速。

### 算法 2：定向 GPS 噪声 (模拟信号)

**问题**：完美的直线和圆弧太假了。 **方案**：加入 GPS 信号波动。但 360° 的随机偏移会导致轨迹“后退”，这更假。 **实现**：

1. **只做“左/右”偏移**。
2. 重写 `interpolate_straight` 和 `interpolate_arc` 函数，使其不仅返回 `(Point)`，还返回 `(Point, travel_bearing)`（点和当前行进方向）。
3. 在工作线程中，当“随机偏移”触发时，计算前进方向的**垂直方向 `lateral_bearing`** (`travel_bearing + 90°`)。
4. 沿这个“左/右”方向随机一个距离（例如 `-1.5` 到 `+1.5` 米），实现“左右漂移，绝不后退”。

### 算法 3：防漂移 (模拟连续性)

**问题**：停止模拟后，下次启动又会“跳”回起点，这很突兀。 **方案**：从上次停止的地方无缝继续。 **实现**：

1. 在 `reset_gui_state` (停止时) 和 `on_closing` (关闭时) 将最后发送的坐标 `last_known_location` 保存到 `track_sim_config.json`。
2. 启动时，如果勾选了“从上次位置开始”，程序会加载这个点。
3. `start_simulation` 函数会调用 `find_closest_start_index` 算法，遍历新生成的10公里路径点，找到距离 `last_known_location` **最近的那个点**。
4. 程序从这个“最近点”的索引开始循环，实现了无缝衔接。

## 第五章：功能完善与 Bug 修复

在核心功能完善后，我们进行了大量的易用性 (Quality of Life) 优化和 Bug 修复：

- **功能**：加入了“路径微调”、“坐标预设”、“圆弧角度”调节、“自动检测目录 (`psutil`)”、“暂停时手动控制”、“一键归位”等功能。
- **Bug 修复**：
  1. **“跳过等待”按钮失效**：将 `subprocess.run` (阻塞) 改为 `subprocess.Popen` (非阻塞)，让按钮在等待时立刻可用。
  2. **“手动控制”失效**：重写了逻辑，使其只在“暂停”时生效，并通过临时线程发送命令，实现了“暂停探索，继续归位”的正确功能。
  3. **`tkinter` 滚动空白**：重构了 `Canvas` 和 `Scrollbar` 的 `bind` 事件，修复了滚动时界面崩溃的问题。
  4. **几何错误**：修复了 `calculate_midpoint` 中致命的 `point=a` 拼写错误。
  5. **布局美化**：将窗口宽度从 `650px` 调整到 `580px`，并重排 `grid` 布局，使其更紧凑美观。

## 关于 AI 协作 (Gemini)

值得一提的是，本项目的整个开发过程是在与 Google 的 Gemini Pro/Advanced 模型高度协作下完成的。

`school-runing-dut` 从一个简单的想法，演变成了一个功能齐全的“拟人化”模拟器。这个开发过程很有挑战性，尤其是在获得 `ldconsole.exe help` 输出后才取得了关键进展。

这个项目展示了：一个好的工具，诞生于对一个具体需求的反复推敲和对“失败”的深入分析。

*要查看完整功能列表和操作指南，请参阅* [*README.md*](https://www.google.com/search?q=https://github.com/tianxingleo/school-runing-dut/blob/main/README.md)*。*
