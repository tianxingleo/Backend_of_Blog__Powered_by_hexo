---
title: 质数筛选算法的汇总
date: 2025-10-23 20:29:50
tags:
  - cpp
  - 算法
  - 质数筛
ai: true
main_color: #66CCFF
---



------

## 一、基础方法：试除法（Trial Division）

### 思路

对每个数 `n`，尝试用小于等于 `√n` 的所有数去除，如果能整除说明不是质数。

### 示例代码

```cpp
#include <iostream>
#include <cmath>
using namespace std;

bool isPrime(int n) {
    if (n < 2) return false;
    for (int i = 2; i <= sqrt(n); i++) {
        if (n % i == 0) return false;
    }
    return true;
}

int main() {
    for (int i = 2; i <= 100; i++) {
        if (isPrime(i)) cout << i << " ";
    }
}
```

### 时间复杂度

- 检测一个数是否为质数：O(√n)
- 检测 1~N 所有数：O(N√N)

### 优化点

1. 只判断奇数（偶数直接跳过）。

2. 先排除 2 和 3，再从 5 开始，步长为 6。

   ```cpp
   for (int i = 5; i * i <= n; i += 6)
       if (n % i == 0 || n % (i+2) == 0) return false;
   ```

------

## 二、埃拉托斯特尼筛法（Sieve of Eratosthenes）

### 思路

一次性找出所有小于 N 的质数。
 核心思想：

> 从 2 开始，将每个质数的倍数标记为非质数。

### 示例代码

```cpp
/*
这是一个欧拉筛算法的实现
*/

#include<stdio.h>
#include<stdbool.h>
int main(){
    int N;
    scanf("%d",&N);
    bool zhishu[N+1];
    int zhishu_1[N+1];
    int C=0;
    for (int i=0;i<=N;i++){
        zhishu[i]=1;
    }
    for (int i=0;i<=N;i++){
        zhishu_1[i]=0;
    }
    for(int i=2;i<=N;i++){

        if(zhishu[i]==1){
            zhishu_1[C]=i;
            C++;
        }

        for(int j=0;zhishu_1[j]!=0&&zhishu_1[j]*i<=N;j++){
            zhishu[i*zhishu_1[j]]=0;
            if(i%zhishu_1[j]==0){
                break;
            }
        }



        /*
        for (int j=2;j<=i&&i*j<=N;j++){
        
            
            if (zhishu[j]==1){
                zhishu[i*j]=0;
            }
            if (i%j==0){
                break;
            }
               
        } */
    }
    int sum=0;
    for (int i=0;zhishu_1[i]!=0;i++){
        printf("%d\n",zhishu_1[i]);
        sum++;
    }
    printf("%d",sum);

    return 0;
}
```



```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<bool> isPrime(int n) {
    vector<bool> prime(n + 1, true);
    prime[0] = prime[1] = false;

    for (int i = 2; i * i <= n; i++) {
        if (prime[i]) {
            for (int j = i * i; j <= n; j += i)
                prime[j] = false;
        }
    }
    return prime;
}

int main() {
    int N = 100;
    auto prime = isPrime(N);
    for (int i = 2; i <= N; i++)
        if (prime[i]) cout << i << " ";
}
```

### 时间复杂度

- O(N log log N)
- 空间复杂度：O(N)

### 特点

非常高效，适合生成大量质数，比如到 1e7（千万级）。

------

## 三、欧拉筛/线性筛（Euler Sieve / Eratosthenes Linear Sieve）

### 思路

在埃氏筛的基础上改进，每个数只会被它的 **最小质因子（least prime factor）** 筛掉一次，做到真正意义上的 O(N)。

### 示例代码

```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> primes;
vector<bool> isPrime;

void linearSieve(int n) {
    isPrime.assign(n + 1, true);
    isPrime[0] = isPrime[1] = false;

    for (int i = 2; i <= n; i++) {
        if (isPrime[i]) primes.push_back(i);
        for (int p : primes) {
            if (i * p > n) break;
            isPrime[i * p] = false;
            if (i % p == 0) break;
        }
    }
}

int main() {
    int N = 100;
    linearSieve(N);
    for (int p : primes) cout << p << " ";
}
```

### 时间复杂度

- 真正意义上的 O(N)
- 空间复杂度：O(N)

### 特点

- 比埃拉托斯特尼筛更快。
- 常用于竞赛、百万级以上范围。

------



## 来自Chatgpt的算法：

## 四、高级算法（用于大范围或单个大数）

### 1. **分段筛法（Segmented Sieve）**

- 用于当 N 很大（比如 10^12），但只想筛某个区间 `[L, R]` 的质数。
- 基于普通筛，但只存储当前区间。
- 适合节省内存。

### 2. **Miller-Rabin 素性测试**

- 一种**概率性算法**，用于检测超大数（>10^12）。
- 时间复杂度 O(k log³n)，非常快。
- 实际应用：RSA加密、随机大质数生成。

------

## 综合比较

| 算法         | 适用范围 | 时间复杂度          | 特点               |
| ------------ | -------- | ------------------- | ------------------ |
| 试除法       | 单个数   | O(√n)               | 简单但慢           |
| 埃氏筛       | ≤10^7    | O(N log log N)      | 快速生成多个质数   |
| 线性筛       | ≤10^8    | O(N)                | 竞赛常用，效率极高 |
| 分段筛       | ≤10^12   | O(N log log N) 局部 | 节省内存           |
| Miller-Rabin | 超大数   | O(k log³n)          | 用于判断大数质性   |

------

