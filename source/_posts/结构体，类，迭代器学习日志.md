---
title: 结构体，类，迭代器学习日志
date: 2025-11-10 09:57:07
tags:
  - cpp
  - 学习
---

<!-- toc -->



# 结构体

## 🧐 什么是 C++ 结构体？



结构体（`struct`）可以看作是**轻量级的数据集合**。它的主要目的是将一组逻辑上相关的数据成员（可以是不同的数据类型）打包在一起。

例如，您可以定义一个表示“学生”的结构体，其中包含学生的姓名（`string`）、学号（`int`）和年龄（`int`）等信息。



### **基本语法**



C++

```
struct 结构体名称 {
    // 成员变量（数据成员）
    类型 成员名1;
    类型 成员名2;
    // ...
    
    // （可选）成员函数
    // ...
}; // 注意末尾的分号
```



### **示例**



C++

```
struct Student {
    std::string name; // 姓名
    int id;           // 学号
    int age;          // 年龄
};
```

------



## 📝 结构体的使用





### **1. 声明结构体变量（实例化）**



在定义了结构体类型后，您可以像使用内置数据类型（如 `int` 或 `double`）一样来声明结构体变量。

C++

```
// 声明一个 Student 类型的变量
Student student1; 
```



### **2. 访问结构体成员**



使用**点运算符 (`.`)** 来访问结构体变量的成员。

C++

```
student1.name = "张三";
student1.id = 1001;
student1.age = 20;

std::cout << "学生姓名: " << student1.name << std::endl; 
```



### **3. 结构体初始化**



您可以在声明变量时使用**花括号 `{}`** 进行初始化。

C++

```
// 方式一：按成员顺序初始化
Student student2 = {"李四", 1002, 21}; 

// 方式二：使用列表初始化（C++11 及其以后推荐）
Student student3{
    "王五", 
    1003, 
    22
};

// 方式三：指定成员初始化（C++20 引入，更安全明确）
// Student student4{.name = "赵六", .id = 1004, .age = 23}; // 仅 C++20 及更高版本支持
```



### **4. 结构体与函数**



结构体可以作为函数的参数或返回值：

- **传值**：将结构体变量的**副本**传递给函数。
- **传引用**：将结构体变量的**引用**传递给函数，可以修改原结构体，且效率更高（推荐）。
- **传指针**：传递结构体变量的**地址**。访问成员时使用**箭头运算符 (`->`)**。

C++

```
void printStudent(const Student& s) { // 传引用（const 避免修改）
    std::cout << s.name << ", ID: " << s.id << std::endl;
}

Student* ptr_s = &student1;
ptr_s->age = 25; // 使用 -> 访问指针指向的结构体成员
```

------



## 🆚 结构体 (`struct`) 与类 (`class`) 的区别



在 **C++** 中，结构体和类**几乎是等价的**，它们都可以拥有数据成员、成员函数、构造函数、析构函数，甚至支持继承和多态。它们之间**最主要的区别**在于**默认的访问权限**：

| **特性**         | **结构体 (struct)**                                          | **类 (class)**                                     |
| ---------------- | ------------------------------------------------------------ | -------------------------------------------------- |
| **默认访问权限** | **`public`**（公有）                                         | **`private`**（私有）                              |
| **用途惯例**     | 通常用于**简单的数据集合**（POCO: Plain Old C++ Object），着重于数据的组合。 | 通常用于**复杂的面向对象设计**，着重于封装和行为。 |

> 🔑 **关键点：** 如果您未显式指定成员的访问权限，结构体中的成员默认是 `public`，而类中的成员默认是 `private`。

例如：

C++

```
struct DataStruct {
    int x; // 默认为 public
private:
    int y; 
};

class DataClass {
    int a; // 默认为 private
public:
    int b;
};
```

------



## 🚀 进阶特性





### **成员函数**



结构体可以包含成员函数，这些函数可以操作结构体内部的数据。

C++

```cpp
struct Point {
    double x;
    double y;

    // 成员函数
    void print() const { // const 表示该函数不会修改成员数据
        std::cout << "(" << x << ", " << y << ")" << std::endl;
    }
};
// 使用：
Point p1 = {1.0, 2.0};
p1.print(); // 输出：(1, 2)
```



### **构造函数与析构函数**



结构体也可以定义构造函数（用于初始化对象）和析构函数（用于清理资源）。

C++

```cpp
struct Book {
    std::string title;
    int pages;

    // 构造函数
    Book(const std::string& t, int p) : title(t), pages(p) {} 

    // 析构函数（如果需要资源清理）
    ~Book() {
        // ... 清理工作
    }
};

Book myBook("C++ Primer", 1300);
```



# 迭代器

## 🧭 什么是 C++ 迭代器？



迭代器是一种**行为类似于指针**的对象，用于**访问和遍历** STL 容器（如 `std::vector`, `std::list`, `std::map` 等）中的元素。



### 核心作用



1. **统一访问接口：** 无论您使用的是数组、链表还是树，迭代器都提供了一套统一的接口（如 `++`, `*`）来遍历这些容器中的元素，使得算法可以独立于具体的容器类型而工作。
2. **连接算法与容器：** 所有的 STL 算法（如 `std::sort`, `std::find`, `std::copy`）都通过迭代器来指定要操作的元素范围。



### 基础用法



一个典型的迭代器（如 `std::vector<int>::iterator`）主要支持以下操作：

| **运算符**    | **作用**                               | **示例**         |
| ------------- | -------------------------------------- | ---------------- |
| `*`（解引用） | 访问迭代器当前指向的元素的值。         | `*it = 5;`       |
| `++`（自增）  | 将迭代器移动到容器中的**下一个**元素。 | `it++;`          |
| `==`, `!=`    | 比较两个迭代器是否指向同一位置。       | `if (it != end)` |



### 示例



C++

```
#include <iostream>
#include <vector>

int main() {
    std::vector<int> nums = {10, 20, 30, 40};

    // 声明一个迭代器
    std::vector<int>::iterator it = nums.begin();

    // 遍历容器
    while (it != nums.end()) {
        std::cout << *it << " "; // 使用 * 解引用访问元素
        it++;                    // 使用 ++ 移动到下一个元素
    }
    // 输出: 10 20 30 40 
}
```

------



## 📌 重要的迭代器函数



几乎所有的 STL 容器都提供了一对基础函数来获取迭代器：

- **`.begin()`：** 返回指向容器中**第一个元素**的迭代器。
- **`.end()`：** 返回指向容器中**最后一个元素**的**下一个位置**的迭代器（这是一个“过去尾部”位置，不指向任何有效元素）。循环通常以 `it != container.end()` 为终止条件。

此外，还有：

- **`.cbegin()` / `.cend()`：** 返回 **const 迭代器**。它们只能用来读取元素，不能修改元素的值。
- **`.rbegin()` / `.rend()`：** 返回 **反向迭代器**。它们用于从容器的末尾向开头遍历。

------



## 🗂️ 迭代器的分类（种类）



C++ STL 根据迭代器支持的操作集合，将其分为五种不同的类型，这决定了容器和算法如何有效地访问元素：

| **迭代器类别**                                 | **支持的操作**                                             | **适用容器/特点**                                            |
| ---------------------------------------------- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| **1. 输入迭代器** (`InputIterator`)            | `++`, `*` (只读), `==`, `!=`                               | 只支持单次遍历，用于读取操作（如 `std::find`）。             |
| **2. 输出迭代器** (`OutputIterator`)           | `++`, `*` (只写)                                           | 只支持单次遍历，用于写入操作（如 `std::copy` 到新位置）。    |
| **3. 前向迭代器** (`ForwardIterator`)          | 读/写，`++`                                                | 支持多次遍历同一序列（如 `std::forward_list`）。             |
| **4. 双向迭代器** (`BidirectionalIterator`)    | 读/写，`++`, **`--`**                                      | 支持向前和向后遍历（如 `std::list`, `std::set`, `std::map`）。 |
| **5. 随机访问迭代器** (`RandomAccessIterator`) | 读/写，`++`, `--`, **`+` (加法), `-` (减法), `[]` (下标)** | **支持像指针一样的随机访问**和算术运算，效率最高（如 `std::vector`, `std::deque`, `std::array`）。 |

> 💡 **关键点：** 越往后的迭代器功能越强大，它们兼容前面类别的所有功能（除了输出迭代器）。例如，`std::vector` 使用的随机访问迭代器自然也支持双向、前向、输入和输出的功能。

------



## ⚠️ 迭代器失效 (Iterator Invalidation)



迭代器失效是使用 C++ 容器和迭代器时最常见的错误之一。

**迭代器失效**指的是在迭代器指向的容器上执行了某些操作后，该迭代器不再指向它原来的或任何有效的元素。



### 常见的失效情况



| **容器类型**                          | **导致迭代器失效的操作**                                     | **解决方案/注意点**                                          |
| ------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **`std::vector`**                     | **插入**（除尾部）、**删除**（除尾部）、**调整大小**（`resize`, `reserve`） | 插入或删除操作后，必须使用函数返回的新迭代器。               |
| **`std::list`/`std::map`/`std::set`** | **删除**操作 (`erase`)                                       | `erase` 函数会返回一个指向被删除元素**下一个元素**的有效迭代器。 |

**示例（`std::vector` 的删除操作）：**

C++

```cpp
std::vector<int> v = {1, 2, 3, 4};
// 错误示例：it 指向 2，删除后 it 失效
// for (auto it = v.begin(); it != v.end(); it++) {
//     if (*it == 2) v.erase(it); 
// } 

// 正确做法：使用 erase 的返回值更新迭代器
for (auto it = v.begin(); it != v.end(); ) {
    if (*it == 2) {
        it = v.erase(it); // erase 返回下一个有效元素的迭代器
    } else {
        it++; // 只有在没有删除元素时才自增
    }
}
```



# sort()

## 🚀 `std::sort` 概述



`std::sort` 是 C++ 标准模板库（STL）中定义在 `<algorithm>` 头文件里的一个函数，用于对序列（通常是容器的一部分）中的元素进行排序。



### `std::sort` 的基本调用形式



C++

```
#include <algorithm>
#include <vector>
// ...
std::sort(first_iterator, last_iterator, comparison_function_or_object);
```



### 参数解释：



1. **`first_iterator`** 和 **`last_iterator`**：
   - 它们是**迭代器**（**专有名词**：**Iterator**）。
   - `first_iterator` 指向要排序范围的**起始元素**。
   - `last_iterator` 指向要排序范围的**结束元素**的**下一个位置**（遵循 STL 容器的**左闭右开**区间 $[first, last)$ 规则）。
2. **`comparison_function_or_object`** (可选)：
   - 这是用于自定义排序规则的参数。如果不提供，`std::sort` 默认使用 `<` 运算符进行**升序**排序。

------



## 📝 自定义排序规则的写法



自定义排序规则的核心是提供一个**比较函数**或**比较对象**。这个函数或对象必须满足以下条件：

1. 它接受两个参数，这两个参数的类型是待排序序列中元素的类型（或可隐式转换为该类型）。
2. 它必须返回一个 **`bool`** 类型的值。
3. 它必须实现**严格弱序**（**专有名词**：**Strict Weak Ordering**）。



### 写法一：使用普通函数（Function Pointer）



这是最传统、最容易理解的方式。



#### 示例：实现降序排序（从大到小）



C++

```
// 待排序的元素类型是 int
bool compare_desc(int a, int b) {
    // 如果 a > b，我们认为 a 应该排在 b 的前面
    // 返回 true 表示 a 应该放在 b 的前面
    return a > b; 
}

// 调用 sort 函数
std::vector<int> numbers = {3, 1, 4, 1, 5};
std::sort(numbers.begin(), numbers.end(), compare_desc); 
// 排序结果: {5, 4, 3, 1, 1}
```



### 写法二：使用 Lambda 表达式（Lambda Function）



在现代 C++ (C++11 及以后) 中，这是最**推荐**和最简洁的方式。



#### 示例：实现降序排序



C++

```
std::vector<int> numbers = {3, 1, 4, 1, 5};

std::sort(numbers.begin(), numbers.end(), [](int a, int b) {
    // Lambda 表达式：匿名函数
    return a > b; // 降序
});
// 排序结果: {5, 4, 3, 1, 1}
```



### 写法三：使用函数对象（Functor / Struct / Class）



函数对象是将比较逻辑封装在一个类中，该类重载了**圆括号运算符 `()`**。



#### 示例：实现降序排序



C++

```cpp
// 函数对象（专有名词：Functor）
struct CompareDescending {
    // 重载圆括号运算符，使其可以像函数一样被调用
    bool operator()(int a, int b) const { 
        return a > b; // 降序
    }
};

std::vector<int> numbers = {3, 1, 4, 1, 5};
CompareDescending comp_obj; // 实例化对象
std::sort(numbers.begin(), numbers.end(), comp_obj);
// 排序结果: {5, 4, 3, 1, 1}
```



# 匿名函数

## 🧐 什么是匿名函数（Lambda 表达式）？



匿名函数，顾名思义，就是**没有名称（标识符）的函数**或子程序。它通常被定义在一个表达式内部，并可以直接作为参数传递或赋值给一个变量。

在 **C++** 中，匿名函数特指 **Lambda 表达式**，这是 C++11 标准引入的一项强大特性。



### Lambda 表达式的结构



C++ Lambda 表达式的语法结构如下：

C++

```
[捕获列表] (参数列表) -> 返回类型 { 函数体 }
```

| **部分**      | **专有名词**     | **作用**                                                     |
| ------------- | ---------------- | ------------------------------------------------------------ |
| `[捕获列表]`  | **Capture List** | 决定 Lambda 内部可以访问哪些**外部局部变量**，以及是以**传值**还是**传引用**的方式访问。 |
| `(参数列表)`  | Parameters       | 定义 Lambda 接受的输入参数，与普通函数相同。                 |
| `-> 返回类型` | Return Type      | **可选**。指定函数的返回类型。如果函数体只有一条 `return` 语句，编译器通常可以自动推导，可以省略。 |
| `{ 函数体 }`  | Body             | 实际执行的代码块，与普通函数相同。                           |

**简单示例：**

C++

```
// 这是一个 Lambda 表达式，接受两个 int 参数并返回它们的和
auto add = [](int a, int b) { 
    return a + b; 
};

// 像调用函数一样使用它
int result = add(5, 3); // result = 8
```

------



## 💡 匿名函数（Lambda）的主要用处



匿名函数的主要价值在于**简洁性、局部性和即时性**，极大地提高了代码的灵活性和可读性。



### 1. 作为算法的自定义比较/操作规则（最常见用途）



这是 Lambda 表达式最常见的应用场景。它们完美地替代了之前需要单独定义的普通函数或函数对象（Functor）。

- **场景：** 在使用 `std::sort`、`std::find_if`、`std::for_each` 等 STL 算法时，需要传入一个操作或比较规则。
- **优势：** 无需在全局或类中定义一个只用一次的函数，逻辑直接写在调用点，保持代码的局部性和清晰度。

**示例（排序）：**

C++

```
std::vector<int> nums = {5, 2, 8, 1};
int N = 3; 

// 使用 Lambda 表达式进行降序排序
std::sort(nums.begin(), nums.end(), [](int a, int b) {
    return a > b; // 实现降序
});

// 使用 Lambda 表达式查找第一个大于 N 的元素
auto it = std::find_if(nums.begin(), nums.end(), [N](int x) {
    return x > N; // 注意：这里通过捕获列表 [N] 访问了外部局部变量 N
}); 
```



### 2. 捕获外部状态（形成**闭包** - Closure）



通过**捕获列表 `[]`**，Lambda 表达式可以访问并操作其定义范围内的局部变量，从而形成一个**闭包**（**专有名词**：Closure）。这是 Lambda 相比普通函数指针的巨大优势。

- **传值捕获** `[var]`：Lambda 内部持有外部变量的一个**副本**（不可修改）。
- **传引用捕获** `[&var]`：Lambda 内部持有外部变量的一个**引用**（可修改原变量）。
- **默认捕获** `[=]` 或 `[&]`：分别代表所有局部变量都按值或按引用捕获。

**示例（捕获）：**

C++

```
int counter = 0;
// 捕获 counter 的引用 [&counter]，以便在 Lambda 内部修改外部变量
auto incrementer = [&counter]() {
    counter++;
    std::cout << "当前计数: " << counter << std::endl;
};

incrementer(); // 输出: 当前计数: 1
incrementer(); // 输出: 当前计数: 2
```



### 3. 用作线程和异步任务的回调函数



在多线程和异步编程中，匿名函数常被用作 `std::thread` 或 `std::async` 的执行体，可以非常方便地将任务逻辑和所需的环境变量打包在一起。

**示例（线程）：**

C++

```
// 创建一个新线程，执行 Lambda 表达式中的任务
std::thread t([]() {
    std::cout << "我在新线程中运行!" << std::endl;
});
t.join(); 
```



### 4. 立即执行的函数表达式（IIFE 模式）



有时使用 Lambda 表达式来定义一个立即执行的函数，可以在局部范围内初始化一个 `const` 变量，避免创建临时变量污染周围的作用域。

**示例：**

C++

```cpp
const int final_value = []() {
    int temp = 5;
    temp += 10;
    return temp * 2;
}(); // 注意末尾的 ()，表示立即调用这个 Lambda
// final_value = 30
```
