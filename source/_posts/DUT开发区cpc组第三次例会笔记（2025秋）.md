---
title: DUT开发区cpc组第三次例会笔记（2025秋）
date: 2025-11-07 10:51:57
toc: true 
toc_number: false # 是否显示编号
tags:
  - cpc
  - cpp
  - 算法
  - 搜索
---

> 递归、分治、深度优先搜索（DFS）、广度优先搜索（BFS）以及递归分治算法在解决编程问题中的应用

## BFS与DFS

### 1. 🔍 BFS (广度优先搜索 / Breadth-First Search)

#### 概念



BFS 是一种**地毯式**、**一层一层**向外扩展的搜索策略。它会先访问离起始点最近的所有节点，然后再访问距离起始点第二近的所有节点，以此类推。

想象一下往湖中扔一块石头，水波纹就是 BFS 的扩展方式。



#### 核心特点



- **策略：** **先广后深**，优先探索所有邻近节点。
- **实现：** 通常使用 **队列（Queue，先进先出/FIFO）** 来存储接下来要访问的节点。
- **应用：** 主要用于寻找**非加权图**中的**最短路径**（因为它是按距离一层层搜索的）。

| **距离起始点** | **访问顺序**            |
| -------------- | ----------------------- |
| 1              | 访问所有距离为 1 的节点 |
| 2              | 访问所有距离为 2 的节点 |
| 3              | 访问所有距离为 3 的节点 |

------



### 2. 🌲 DFS (深度优先搜索 / Depth-First Search)





#### 概念



DFS 是一种**一根筋**、**走到黑**的搜索策略。它会沿着一个分支尽可能深地搜索下去，直到无法再深入为止，然后才会**回溯（Backtrack）**到上一个节点，探索其他未访问的分支。

想象一下在迷宫中沿着一面墙走，直到撞墙才回头。



#### 核心特点



- **策略：** **先深后广**，优先探索当前路径的尽头。
- **实现：** 通常使用 **栈（Stack，后进先出/LIFO）** 来实现，或者更常见的是使用**递归（Recursion）**。
- **应用：** 主要用于寻找**所有可能的路径**、**连通分量**、**拓扑排序**以及你目前遇到的**组合/回溯问题**。

| **步骤** | **动作**                                                   |
| -------- | ---------------------------------------------------------- |
| 1        | 从起点出发，选择**一条**未访问的分支，不断深入。           |
| 2        | 到达分支末尾（叶子节点）或遇到已访问节点。                 |
| 3        | **回溯**到上一个岔路口，选择另一条未访问的分支，继续深入。 |

------



### 3. ⚖️ 主要区别总结



| **特性**     | **广度优先搜索 (BFS)**                 | **深度优先搜索 (DFS)**                     |
| ------------ | -------------------------------------- | ------------------------------------------ |
| **搜索方式** | **一层层**向外扩展                     | **一条路**走到尽头再回溯                   |
| **数据结构** | **队列 (Queue)**                       | **栈 (Stack) / 递归 (Recursion)**          |
| **优点**     | **能找到最短路径**（在非加权图中）     | 占用**内存少**（因为只存储当前路径）       |
| **缺点**     | 需要更多内存（存储所有待访问的节点）   | **不能保证找到最短路径**                   |
| **典型应用** | 最短路径、连通性判断、社交网络关系查找 | 组合问题、拓扑排序、迷宫路径查找、回溯算法 |

在你的**“从 $n$ 个数中选 $k$ 个数求和”**的题目中，你需要找到所有可能的 $k$ 个数组合，因此**DFS（回溯）**是解决这类问题的标准算法。



## BFS的模版

### C++ 实现示例

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <map>
#include <set>

// 假设图由邻接表表示
// Key: 节点编号 (int), Value: 与之相连的邻居节点列表 (vector<int>)
using Graph = std::map<int, std::vector<int>>;

/**
 * @brief 广度优先搜索 (BFS) 的核心函数
 *
 * @param graph 邻接表表示的图
 * @param startNode 起始节点
 */
void bfs(const Graph& graph, int startNode) {
    // 1. 初始化队列和访问集合
    std::queue<int> q;
    std::set<int> visited;

    // 2. 将起始节点加入队列和已访问集合
    q.push(startNode);
    visited.insert(startNode);

    // 3. 开始主循环：当队列非空时，持续处理
    while (!q.empty()) {
        // 4. 取出队列头部节点 (访问当前节点)
        int currentNode = q.front();
        q.pop();

        // ----------------------------------------------------
        // **A. 访问操作/处理逻辑**
        // 在这里进行对 currentNode 的操作，例如：
        // - 打印节点
        // - 检查是否是目标节点 (如果是，可以提前返回)
        // - 记录最短路径信息等
        std::cout << "正在访问节点: " << currentNode << std::endl;
        // ----------------------------------------------------

        // 5. 遍历当前节点的所有邻居
        // 检查该节点是否存在于图中
        if (graph.count(currentNode)) {
            for (int neighbor : graph.at(currentNode)) {
                
                // 6. 检查邻居是否已被访问
                if (visited.find(neighbor) == visited.end()) {
                    
                    // 7. 将未访问的邻居加入队列和已访问集合
                    q.push(neighbor);
                    visited.insert(neighbor);
                    
                    // ----------------------------------------------------
                    // **B. 路径记录/额外操作**
                    // 如果需要记录路径，通常在这里记录：
                    // parent[neighbor] = currentNode;
                    // distance[neighbor] = distance[currentNode] + 1;
                    // ----------------------------------------------------
                }
            }
        }
    }
}

// 示例：图的构建与测试
int main() {
    // 构造一个简单的图
    // 1 -> 2, 1 -> 3
    // 2 -> 4, 3 -> 4, 3 -> 5
    // 4 -> 5
    Graph myGraph = {
        {1, {2, 3}},
        {2, {4}},
        {3, {4, 5}},
        {4, {5}},
        {5, {}} // 节点 5 没有出边
    };

    int startNode = 1;
    
    std::cout << "--- 开始 BFS (从节点 " << startNode << " 开始) ---" << std::endl;
    bfs(myGraph, startNode);
    std::cout << "--- BFS 结束 ---" << std::endl;

    return 0;
}
```



### 3. 套路总结 (BFS 步骤)



广度优先搜索的基本流程可以概括为以下四个步骤：

1. **初始化：** 创建一个**队列** (`queue`) 用于存储待访问节点，创建一个**已访问集合/数组** (`visited`)。
2. **起点入队：** 将起始节点加入队列，并标记为已访问。
3. **循环处理：** 当队列不为空时，重复执行以下操作：
   - 从队列头部取出一个节点 `u`（并将其弹出）。
   - **处理 `u`：** 对节点 `u` 执行需要的操作（如打印、检查目标等）。
   - **遍历邻居：** 遍历节点 `u` 的所有邻居节点 `v`。
4. **邻居入队：** 如果邻居节点 `v` **未被访问**，则将其加入队列，并标记为已访问。
