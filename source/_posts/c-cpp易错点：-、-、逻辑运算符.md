---
title: C/C++ 易错点深度解析：指针、结构体与运算符优先级 
date: 2025-11-19 10:28:47
tags:
  - c
  - cpp
  - 学习
  - 指针
  - 链表
  - 结构体
---



## 1. 运算顺序的三大基石

在 C/C++ 中，面对一个复杂的表达式（尤其是包含指针和结构体的表达式），理解运算结果必须掌握三个核心概念：

### **1. 优先级 (Precedence)**

定义了在没有括号的情况下，**哪个运算符**应该优先与其操作数结合。

- **口诀**：初等运算符（`()` `[]` `.` `->`） > 单目运算符（`++` `--` `*` `&` `!`） > 算术运算符 > 关系运算符 > 逻辑运算符 > 赋值运算符。
- **例子**：`*p->next` 中，`->` 优先级高于 `*`，所以等价于 `*(p->next)`。

### **2. 结合性 (Associativity)**

定义了当表达式中出现**优先级相同**的运算符时，结合的方向。

- **左结合 (Left-to-right)**：大多数双目运算符（`+` `-` `*` `/` `.` `->`）。例如 `a - b - c` 等价于 `(a - b) - c`。
- **右结合 (Right-to-left)**：**单目运算符**（前缀 `++` `--`、`*`、`&`、`!`）和**赋值运算符**（`=`）。例如 `*++p` 等价于 `*(++p)`。

### **3. 求值顺序 (Order of Evaluation)**

这是最容易混淆的概念。优先级和结合性决定了代码怎么“画括号”（语法结构），但**不一定**决定哪个操作数先被计算。

- **警告**：除了 `&&`、`||`、`,` (逗号运算符) 和 `?:` 外，C++ 标准**不保证**操作数的计算顺序。`f(a) + g(b)` 中，先调用 `f` 还是 `g` 是未知的。

## 2. 指针与自增/自减的“爱恨情仇”

这是 C 语言指针的精髓，也是面试中的重灾区。我们需要特别关注 **后缀 `++`**（优先级高，左结合）与 **解引用 `\*`**（优先级较低，右结合）的混合使用。

假设有如下定义：

```
int arr[] = {10, 20, 30, 40};
int *p = arr; // p 指向 arr[0] (值为10)
```

| 表达式        | 优先级分解                         | 结合性            | 执行逻辑 (Step-by-Step)                                      | 结果 (假设初始 p=arr)                         |
| ------------- | ---------------------------------- | ----------------- | ------------------------------------------------------------ | --------------------------------------------- |
| **`\*p++`**   | `(p++)` 先结合，但在表达式中取旧值 | **左结合** (后缀) | 1. 记录 `p` 的当前指向。2. `p` 自增指向下一个元素。3. 对**旧的** `p` 进行解引用。 | 结果为 **10**`p` 指向 `arr[1]` (20)           |
| **`(\*p)++`** | 括号强制改变优先级                 | -                 | 1. 解引用 `p` 得到 `arr[0]`。2. 对该**值**进行后缀自增。     | 结果为 **10**`arr[0]` 变为 **11**`p` 指向不变 |
| **`\*++p`**   | `*` 和 `++`(前缀) 同级             | **右结合**        | 1. `p` 先自增指向 `arr[1]`。2. 解引用**新**的 `p`。          | 结果为 **20**`p` 指向 `arr[1]`                |
| **`++\*p`**   | `*` 和 `++`(前缀) 同级             | **右结合**        | 1. 解引用 `p` 得到 `arr[0]`。2. 对该**值**进行前缀自增。     | 结果为 **11**`arr[0]` 变为 **11**`p` 指向不变 |

### **核心场景：遍历数组/字符串**

最经典的写法是利用 `*p++`：

```
char str[] = "Hello";
char *ptr = str;
while (*ptr != '\0') {
    putchar(*ptr++); // 取出当前字符打印，然后指针后移
}
```

## 3. 结构体、联合体与点/箭头运算符

在操作链表、树等复杂数据结构时，`->` (箭头) 和 `.` (点) 的使用非常频繁。它们属于**最高优先级**（第1级），且是**左结合**。

假设有以下结构体：

```
struct Node {
    int val;
    Node* next;
};
Node n = {1, nullptr};
Node* p = &n;
```

### **常见组合解析**

#### **1. `p->val` 与 `(\*p).val`**

- `->` 是 `(*p).` 的语法糖。
- 由于 `.` 优先级高于 `*`，所以 `*p.val` 会被解析为 `*(p.val)`（错误，因为 p 是指针没有成员 val）。
- **必须加括号**：`(*p).val`。

#### **2. `++p->val`**

- **解析**：`->` 优先级高于 前缀`++`。
- **等价于**：`++(p->val)`。
- **含义**：访问 `p` 指向节点的 `val` 成员，并将该**成员的值**加 1。
- **结果**：Node 中的 `val` 变大，指针 `p` 不动。

#### **3. `p->next++` (极易错)**

- **解析**：`->` 优先级高于 后缀`++`？**不，它们是同一优先级（第2级，见下表），但都是左结合**。或者更准确地说，后缀运算符在语法绑定上最紧密。
- **等价于**：`(p->next)++`。
- **含义**：取出 `p` 的 `next` 指针（注意是取出指针本身的值），表达式结果是 `next` 的旧地址，然后 `next` 指针自增（指向内存中下一个 Node 指针位置，通常无意义除非是数组）。
- **注意**：这**不是**移动 `p` 指针到下一个节点！

#### **4. 链表常用操作**

如果要移动指针 `p` 到下一节点：

```
p = p->next; // 正确：赋值
```

如果要操作下一节点的值：

```
p->next->val = 10; // 左结合：(p->next)->val
```

## 4. 逻辑运算符的短路求值 (Short-Circuit)

这是 C++ 中极少数**保证求值顺序**的运算符。

### **A. 逻辑 AND (`&&`)**

`A && B`：若 A 为 `false`，则 B **绝不会**执行。

### **B. 逻辑 OR (`||`)**

`A || B`：若 A 为 `true`，则 B **绝不会**执行。

### **🎯 经典应用场景**

#### **1. 链表安全遍历**

防止访问空指针是链表操作的第一要务。

```
// 错误写法：如果 p 是 nullptr，p->next 会崩溃
if (p->next && p) { ... } 

// 正确写法：先检查 p
if (p && p->next) { 
    // 只有 p 存在，才会去访问 p->next
}
```

#### **2. 带有副作用的条件**

```
int x = 10;
// x == 10 为真，右侧 (x += 5) 不会被执行
if (x == 10 || (x += 5) > 10) {
    cout << x; // 输出 10，而不是 15
}
```

## 5. C/C++ 运算符优先级速查表 (增强版)

为了方便记忆，我们将运算符按功能分层（优先级从高到低）：

| 优先级组          | 运算符                                                       | 结合性     | 关键说明                                                     |
| ----------------- | ------------------------------------------------------------ | ---------- | ------------------------------------------------------------ |
| **1 (最高)**      | `::`                                                         | -          | 作用域解析                                                   |
| **2 (后缀)**      | `()` `[]` `.` `->`  `++`(后缀) `--`(后缀)                    | **左结合** | **结构体/数组/函数调用最优先结合**。`arr[i]++` 是数组元素自增。 |
| **3 (前缀/单目)** | `++`(前缀) `--`(前缀)  `!` `~`  `*`(解引用) `&`(取地址)  `sizeof` `(type)` | **右结合** | **从右向左运算**。`*++p` 先自增 p 再解引用。                 |
| **4 (算术)**      | `*` `/` `%`                                                  | 左结合     | 乘除模                                                       |
| **5 (算术)**      | `+` `-`                                                      | 左结合     | 加减                                                         |
| **6 (移位)**      | `<<` `>>`                                                    | 左结合     |                                                              |
| **7 (关系)**      | `<` `<=` `>` `>=`                                            | 左结合     |                                                              |
| **8 (相等)**      | `==` `!=`                                                    | 左结合     |                                                              |
| **9-12 (位运算)** | `&` `^` `                                                    | `          | 左结合                                                       |
| **13 (逻辑)**     | `&&`                                                         | 左结合     | **短路求值**                                                 |
| **14 (逻辑)**     | `                                                            |            | `                                                            |
| **15 (三目)**     | `? :`                                                        | **右结合** | `a ? b : c ? d : e`                                          |
| **16 (赋值)**     | `=` `+=` `-=` `*=` 等                                        | **右结合** | `a = b = c`                                                  |
| **17 (最低)**     | `,`                                                          | 左结合     | **保证顺序**，取最后一个表达式的值                           |

## 6. 避坑指南：未定义行为 (UB)

即使背下了优先级表，也不要写出依赖复杂副作用的代码。C++ 标准对“副作用何时生效”的规定非常宽松。

### **绝对禁止的写法**

1. **修改并读取同一变量**：

   ```
   a[i] = i++; // ❌ 错误：不知道是先取 i 做索引，还是先自增
   printf("%d %d", i++, i); // ❌ 错误：函数参数求值顺序未定义
   ```

2. **多次修改同一变量**：

   ```
   int x = 5;
   x = x++ + ++x; // ❌ 绝对禁止，结果依赖编译器实现
   ```
