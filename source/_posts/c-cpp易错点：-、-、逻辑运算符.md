---
title: c/cpp易错点：++、--、逻辑运算符
date: 2025-11-10 10:28:47
tags:
  - c
  - cpp
  - 学习
---

## 1. 运算顺序的基本概念



在 C++ 中，一个包含多个运算符的表达式的运算顺序通常由以下三个因素决定：

- 

  ### **优先级 (Precedence)**

  

  定义了在没有括号的情况下，**哪个运算符**应该优先与其操作数结合。例如，`*` 的优先级高于 `+`，所以 `a + b * c` 等价于 `a + (b * c)`。

- 

  ### **结合性 (Associativity)**

  

  定义了在表达式中出现**多个相同优先级**的运算符时，它们与操作数的结合方向。

  - **左结合 (Left-to-right):** 从左向右结合。例如，`a - b - c` 等价于 `(a - b) - c`。
  - **右结合 (Right-to-left):** 从右向左结合。例如，赋值运算符 `=` 是右结合的，`a = b = c` 等价于 `a = (b = c)`。

- 

  ### **求值顺序 (Order of Evaluation)**

  

  定义了**操作数表达式**的计算顺序。**请注意：** 优先级和结合性只决定了运算符与操作数的**结合方式**，**绝大多数**情况下，并**不**保证操作数的**求值顺序**。

------



## 2. 递增/递减运算符 (`++` 和 `--`)



`++` (递增) 和 `--` (递减) 运算符有两种形式：**前缀 (Prefix)** 和 **后缀 (Postfix)**。它们的优先级和结合性不同，但更关键的是它们的**语义**和**求值顺序的约束**。

| **运算符**  | **形式**                 | **优先级**     | **结合性** | **语义 (返回值)**          | **示例**                                  |
| ----------- | ------------------------ | -------------- | ---------- | -------------------------- | ----------------------------------------- |
| `++` / `--` | **后缀** (`i++` / `i--`) | 高 (第 2 组)   | 左结合     | 返回**操作数变化前**的值。 | `int y = i++;`  // y = i 的旧值, i 自增 1 |
| `++` / `--` | **前缀** (`++i` / `--i`) | 次高 (第 3 组) | 右结合     | 返回**操作数变化后**的值。 | `int y = ++i;`  // i 自增 1, y = i 的新值 |



### ⚠️ **关于副作用和未定义行为 (Undefined Behavior)**



在使用 `++` 或 `--` 时，必须注意它们会修改操作数的值（产生**副作用**）。在 C++ 中，**除了少数例外**（如 `&&`、`||`、`,`、`?:`），同一表达式中操作数的求值顺序是**不确定**的。

核心规则：

在一个表达式中，如果一个变量被多次修改，或者既被修改又被用于其他操作，并且这些操作之间没有明确的顺序点 (Sequence Point)，那么这个表达式的行为是未定义 (Undefined Behavior) 的。

**未定义行为示例 (应避免):**

- `i = i++;`
- `cout << i++ << i;`
- `i = ++i + i++;`
- `a[i] = i++;`

在上述例子中，编译器不知道应该先读出 `i` 的值，还是先进行 `++` 的副作用，结果可能随编译器和优化级别而异。

------



## 3. 逻辑运算符的**短路求值 (Short-Circuit Evaluation)**



逻辑 AND (`&&`) 和逻辑 OR (`||`) 运算符是 C++ 中少数几个**保证操作数求值顺序**的运算符，它们都遵循**从左到右**的求值顺序，并且具有**短路求值**的特性。



### **A. 逻辑 AND 运算符 (`&&`)**



$$\text{表达式 } A \text{ \&\& } B$$

1. **先求值操作数 $A$。**
2. **判断：** 如果 $A$ 的结果为 **`false` (0)**，那么整个表达式的结果已经确定为 `false`。此时，**操作数 $B$ 将不会被执行 (短路)**。
3. 如果 $A$ 的结果为 **`true` (非 0)**，则必须继续求值操作数 $B$ 来确定最终结果。



### **B. 逻辑 OR 运算符 (`||`)**



$$\text{表达式 } A \text{ || } B$$

1. **先求值操作数 $A$。**
2. **判断：** 如果 $A$ 的结果为 **`true` (非 0)**，那么整个表达式的结果已经确定为 `true`。此时，**操作数 $B$ 将不会被执行 (短路)**。
3. 如果 $A$ 的结果为 **`false` (0)**，则必须继续求值操作数 $B$ 来确定最终结果。



### **🎯 短路求值的应用**



短路求值非常重要，因为它允许进行安全检查，例如：



#### **防止空指针解引用**



C++

```
// 只有当指针 p 不为空时，才会去访问 *p
if (p != nullptr && p->isValid()) {
    // ...
}
```

如果 `p` 是 `nullptr`，`p != nullptr` 结果为 `false`，则 `p->isValid()` **不会被调用**，从而避免程序崩溃。



#### **控制函数调用**



C++

```
int x = 5;
// 只有当 x < 10 为真时，才会调用 myFunc()
if (x < 10 || myFunc()) {
    // ...
}
```

如果 `x` 已经是 5，`x < 10` 为真，则 `myFunc()` **不会被调用**。

------



## 4. C++ 运算符优先级概要



以下是 C++ 运算符优先级分组的简化列表（从高到低）：

| **优先级组** | **运算符**                                                   | **结合性** | **备注**                                                 |
| ------------ | ------------------------------------------------------------ | ---------- | -------------------------------------------------------- |
| **1**        | `::`                                                         | 无         | 作用域解析                                               |
| **2**        | `()` `[]` `.` `->` `++` (后缀) `--` (后缀)                   | 左结合     | 函数调用、数组、成员访问、**后缀**递增/减                |
| **3**        | `++` (前缀) `--` (前缀) `!` `~` `+` (一元) `-` (一元) `*` (解引用) `&` (取地址) `sizeof` `new` `delete` `(type)` | 右结合     | **前缀**递增/减、逻辑/位非、一元正负、指针操作、类型转换 |
| **4**        | `*` `/` `%`                                                  | 左结合     | 乘法、除法、取模                                         |
| **5**        | `+` `-`                                                      | 左结合     | 加法、减法                                               |
| **6**        | `<<` `>>`                                                    | 左结合     | 位移                                                     |
| **7**        | `<` `>` `<=` `>=`                                            | 左结合     | 关系运算符                                               |
| **8**        | `==` `!=`                                                    | 左结合     | 相等运算符                                               |
| **9-12**     | `&` `^` `                                                    | `          | 左结合                                                   |
| **13**       | `&&`                                                         | 左结合     | **逻辑 AND (短路求值)**                                  |
| **14**       | `                                                            |            | `                                                        |
| **15**       | `? :` `=` `+=` `-=` `*=` `/=` 等赋值运算                     | 右结合     | 条件运算符、赋值运算符                                   |
| **16**       | `,`                                                          | 左结合     | 逗号运算符 (**保证求值顺序**)                            |

------



## 扩展

## 1. 理解 `a = (b = c);` (赋值运算符的结合性)





### 🔑 关键：赋值运算符是**右结合**的



在 C++ 中，赋值运算符 (`=`, `+=`, `-=` 等) 的结合性是从**右向左**的（右结合）。



#### **分解步骤：**



对于表达式 `a = (b = c);`，即使您使用了括号，其行为与 `a = b = c;` 完全一致，因为赋值运算符就是右结合的：

1. 最右边的赋值先执行：

   

   $$\mathbf{(b = c)}$$

   - 将 `c` 的值赋给变量 `b`。
   - **关键点：** 赋值操作的结果是**所赋的值**，也就是 `b` 的**新值**（即 `c` 的原始值）。

2. 结果用于左边的赋值：

   

   $$a = \mathbf{(结果)}$$

   - 将上一步 `(b = c)` 运算得到的**值**（即 `c` 的值）赋给变量 `a`。



#### **示例：**



C++

```
int a = 0, b = 0, c = 10;
a = (b = c);

// 执行后：
// 1. (b = c) 执行： b 变为 10，表达式结果为 10
// 2. a = 10 执行： a 变为 10
// 最终 a = 10, b = 10, c = 10
```

**总结：** 赋值运算符的右结合性使得我们可以链式赋值，等同于将最右边操作数的值依次赋给左侧所有变量。

------



## 2. 理解 `++` 和 `--` 在一行中的多个问题 (优先级与求值顺序)



当一行代码中出现多个 `++` 或 `--` 时，问题不再仅仅是**优先级 (Precedence)** 或**结合性 (Associativity)**，而是更深层次的**求值顺序 (Order of Evaluation)** 和**副作用 (Side Effects)**。



### 🔑 关键：优先级和结合性**不决定**操作数的求值顺序



优先级和结合性只决定了**哪个运算符与哪个操作数结合**。例如，`*` 优先级高，所以 `a + b * c` 是 `a + (b * c)`。

**但是**，在计算 `a + (b * c)` 时，C++ 标准**不保证**是先计算 `a` 还是先计算 `(b * c)`。



### 💥 核心问题：未定义行为 (Undefined Behavior - UB)



当一个表达式中，一个变量被**多次修改**，或者**既被修改又被读取用于计算**，而这些操作之间**没有顺序点**时，就会导致**未定义行为**。编译器可以按任何顺序执行这些操作，结果无法预测。



#### **示例 1: 多个修改同一个变量**



C++

```
int i = 5;
i = i++ + ++i; // ❌ 未定义行为 (UB)
```

- **问题：** `i` 在同一行被修改了两次（`i++` 和 `++i`）。
- **后果：** 编译器不知道应该先执行 `i++` 的副作用（将 `i` 增加到 6），还是先执行 `++i` 的副作用（将 `i` 增加到 6）。不同的执行顺序会导致 `i` 最终的值不同。



#### **示例 2: 既读取又修改**



C++

```
int i = 5;
cout << i++ << " " << i; // ❌ 未定义行为 (UB)
```

- **问题：** `i` 在被 `i++` 修改的同时，又被另一个输出操作读取。
- **后果：** 编译器不知道应该先将 `i` 的旧值 (5) 传给第一个 `cout`，还是先执行 `i++` 的副作用 (将 `i` 增加到 6) 并将新值传给第二个 `cout`。



#### **✅ 安全使用的方法：**



1. **使用前缀形式 (`++i`)：** 在单独的语句中或只希望使用**新值**时，前缀形式效率通常更高。

   C++

   ```
   int i = 5;
   ++i; // i = 6
   ```

2. **避免一行中对同一变量的多次副作用：** 即使你知道优先级和结合性，也**不要**写会导致 UB 的代码。使用多行语句分解副作用。

   **将 UB 代码分解为安全代码：**

   C++

   ```cpp
   // ❌ int i = i++ + ++i;
   
   // ✅ 分解后的安全代码
   int i = 5;
   int temp1 = i++;  // i 变为 6, temp1 = 5
   int temp2 = ++i;  // i 变为 7, temp2 = 7
   i = temp1 + temp2; // i = 5 + 7 = 12
   ```
