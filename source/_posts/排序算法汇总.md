---
title: 排序算法汇总
date: 2025-10-29 15:36:02
tags:
  - 算法
  - cpp
  - 学习
ai: true
main_color: "#66ccff"
---

# 各类排序算法介绍

🧩 一、基础交换类算法
------------

### 1️⃣ 冒泡排序（Bubble Sort）

**思路：**

*   每一轮比较相邻元素，如果顺序错误就交换。
*   大的元素会逐步“冒泡”到右端。

**特征：**

*   简单易懂。
*   已经有序时可提前结束。

**复杂度：**

*   平均/最坏：O(n²)
*   最好：O(n)
*   稳定 ✅

#### 实现方法

### 🧠 一、基本思想

冒泡排序是一种 **基础的交换排序算法**，它的核心思想是：

> **通过重复地比较相邻元素并交换，使得较大的元素逐步“冒泡”到序列的末尾。**

每一轮遍历后，未排序部分中最大的元素都会被放到正确的位置上（即“浮”到最右边）。

* * *

### 🔁 二、排序过程示意

假设有一个无序数组：

```
[5, 2, 4, 1, 3]
```

排序过程如下（从左到右比较相邻两个数）：

#### 第1轮：

*   比较 5 和 2 → 交换 → \[2, 5, 4, 1, 3\]
*   比较 5 和 4 → 交换 → \[2, 4, 5, 1, 3\]
*   比较 5 和 1 → 交换 → \[2, 4, 1, 5, 3\]
*   比较 5 和 3 → 交换 → \[2, 4, 1, 3, 5\]

👉 此时最大数 5 已经排到最后。

#### 第2轮：

对前四个数重复比较：

*   \[2, 4, 1, 3\] → 经过比较交换后 → \[2, 1, 3, 4, 5\]

#### 第3轮：

*   \[2, 1, 3\] → 变为 \[1, 2, 3, 4, 5\]

到这里，数组已完全有序。

* * *

### ⚙️ 三、伪代码（Python风格）

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):  # 外层控制趟数
        for j in range(n - 1 - i):  # 内层控制相邻比较
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]  # 交换
```

* * *

### 💡 四、优化思路

可以加一个标志位 `flag`，用于检测某一轮中是否发生过交换：

*   如果一整轮没有交换，说明数组已经有序，可以提前结束。

```python
def bubble_sort_optimized(arr):
    n = len(arr)
    for i in range(n - 1):
        swapped = False
        for j in range(n - 1 - i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        if not swapped:
            break  # 提前终止
```

* * *

### 📊 五、算法特性总结

| 特性                        | 内容                                   |
| --------------------------- | -------------------------------------- |
| **时间复杂度（最坏/平均）** | O(n²)                                  |
| **最佳情况（已排序）**      | O(n)                                   |
| **空间复杂度**              | O(1)（原地排序）                       |
| **稳定性**                  | ✅ 稳定排序（相等元素不会交换相对位置） |
| **适用场景**                | 数据量较小、教学演示、算法初学者入门   |

* * *

是否希望我帮你画一个「冒泡排序动画图解」或「逐步可视化表格」，让过程更直观？

## Response:

当然可以 👍 我来举几个不同类型的例子，让你更直观地理解 **冒泡排序在不同情况下的过程**。

* * *

🌰 示例1：完全无序数组
-------------

数组：`[4, 3, 1, 5, 2]`

| 轮次  | 过程（相邻比较并交换）           | 结果                       |
| ----- | -------------------------------- | -------------------------- |
| 第1轮 | 4>3→换，3>1→换，4<5→不换，5>2→换 | `[3, 1, 4, 2, 5]`          |
| 第2轮 | 3>1→换，3>4→不换，4>2→换         | `[1, 3, 2, 4, 5]`          |
| 第3轮 | 1<3→不换，3>2→换                 | `[1, 2, 3, 4, 5]`          |
| 第4轮 | 1<2→不换                         | `[1, 2, 3, 4, 5]` ✅ 已排序 |

👉 经过 4 轮，数组从乱序变为升序。

* * *

🌿 示例2：部分有序数组
-------------

数组：`[1, 4, 3, 2, 5]`

| 轮次  | 过程                               | 结果                |
| ----- | ---------------------------------- | ------------------- |
| 第1轮 | 1<4→不换，4>3→换，4>2→换，4<5→不换 | `[1, 3, 2, 4, 5]`   |
| 第2轮 | 1<3→不换，3>2→换，3<4→不换         | `[1, 2, 3, 4, 5]` ✅ |
| 第3轮 | 没有交换 → 结束                    | `[1, 2, 3, 4, 5]`   |

👉 通过“无交换检测”，算法可以提前终止，提升效率。

* * *

🔢 示例3：逆序数组（最坏情况）
-----------------

数组：`[5, 4, 3, 2, 1]`

| 轮次  | 过程              | 结果              |
| ----- | ----------------- | ----------------- |
| 第1轮 | 连续交换          | `[4, 3, 2, 1, 5]` |
| 第2轮 | `[3, 2, 1, 4, 5]` |                   |
| 第3轮 | `[2, 1, 3, 4, 5]` |                   |
| 第4轮 | `[1, 2, 3, 4, 5]` |                   |
| 第5轮 | 无需交换 ✅        |                   |

👉 总共需要 (n−1)=4 轮比较，每轮都要交换，是冒泡排序的**最坏情况**。

* * *

🌟 示例4：包含重复元素
-------------

数组：`[2, 1, 3, 1]`

| 轮次  | 过程                     | 结果           |
| ----- | ------------------------ | -------------- |
| 第1轮 | 2>1→换，2<3→不换，3>1→换 | `[1, 2, 1, 3]` |
| 第2轮 | 1<2→不换，2>1→换         | `[1, 1, 2, 3]` |
| 第3轮 | 无需交换 ✅               | `[1, 1, 2, 3]` |

👉 冒泡排序是**稳定排序算法**，两个“1”的相对位置不会被打乱。

* * *

### 2️⃣ 快速排序（Quick Sort）

**思路：**

*   选取一个基准值（pivot），将数组分成两部分：
    *   左边比基准小；
    *   右边比基准大。
*   然后递归地对左右两部分进行排序。

**例子：**

```
[6, 2, 9, 3, 7]
选pivot=6 → 左:[2,3] 右:[9,7]
递归排序 → [2,3,6,7,9]
```

**复杂度：**

*   平均：O(n log n)
*   最坏：O(n²)（当数组已近似有序）
*   不稳定 ❌
*   实际应用中最快之一。

#### 实例：

🧩 一、快速排序的核心思想
--------------

快速排序是一种 **分治（Divide and Conquer）算法**。  
它的思想是：

1️⃣ **选定一个基准值（pivot）**  
2️⃣ **分区（partition）**：把数组分成两部分

*   左边：比 pivot 小的
*   右边：比 pivot 大的  
    3️⃣ **递归排序左右两部分**

最终，整个数组会自然变成有序。

* * *

🧠 二、整体逻辑结构
-----------

```cpp
void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pivotIndex = partition(arr, low, high);  // 分区操作
        quickSort(arr, low, pivotIndex - 1);         // 递归左半部分
        quickSort(arr, pivotIndex + 1, high);        // 递归右半部分
    }
}
```

👉 解释：

*   `low` 和 `high` 表示当前要排序的区间 `[low, high]`
*   `partition()` 返回基准值在排序后的位置 `pivotIndex`
*   左右两边分别递归排序，直到区间长度为1（`low >= high`）

* * *

⚙️ 三、分区函数（partition）
--------------------

```cpp
int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high];   // 选取最后一个元素为基准
    int i = low;             // i 表示“小于 pivot”区域的边界

    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            swap(arr[i], arr[j]);  // 把小的放左边
            i++;
        }
    }

    swap(arr[i], arr[high]);       // 把 pivot 放到正确位置
    return i;                      // 返回 pivot 的最终位置
}
```

👉 逻辑解释：

1.  pivot = 最右端元素
2.  遍历 `[low, high-1]` 区间
    *   如果当前元素比 pivot 小，就与左边区域的边界交换
3.  最后，把 pivot 放到中间位置（左边全小，右边全大）
4.  返回 pivot 的位置（下次递归要用）

* * *

📊 四、运行过程举例
-----------

初始数组：

```
[7, 2, 5, 3, 6, 1]
```

### 第1步

*   pivot = 1
*   一轮 partition 后：

```
[1, 2, 5, 3, 6, 7]
```

*   pivot 位置 = 0

再递归：

*   左边 `[0, -1]`（空）
*   右边 `[1, 5]`

* * *

### 第2步

右区间 `[1, 5]`

*   pivot = 7
*   一轮 partition 后：

```
[1, 2, 5, 3, 6, 7]
```

*   pivot 位置 = 5

再递归：

*   左 `[1, 4]`
*   右 `[6,5]`（空）

* * *

### 第3步

区间 `[1,4]`：

*   pivot = 6
*   partition：

```
[1, 2, 5, 3, 6, 7]
```

*   pivot 位置 = 4

继续递归左右...

🔁 如此递归，最终数组有序。

* * *

✅ 五、完整示例代码
----------

```cpp
#include <iostream>
#include <vector>
using namespace std;

int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high];
    int i = low;
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            swap(arr[i], arr[j]);
            i++;
        }
    }
    swap(arr[i], arr[high]);
    return i;
}

void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pivotIndex = partition(arr, low, high);
        quickSort(arr, low, pivotIndex - 1);
        quickSort(arr, pivotIndex + 1, high);
    }
}

int main() {
    vector<int> arr = {7, 2, 5, 3, 6, 1};
    quickSort(arr, 0, arr.size() - 1);
    for (int x : arr) cout << x << " ";
}
```

输出结果：

```
1 2 3 5 6 7
```

* * *

📘 六、总结
-------

| 步骤 | 内容           | 说明            |
| ---- | -------------- | --------------- |
| 1️⃣    | 选 pivot       | 通常选右端元素  |
| 2️⃣    | 分区 partition | 左小右大        |
| 3️⃣    | 递归左右子区间 | 重复直到长度为1 |
| 4️⃣    | 原地排序       | 不需要新建数组  |

* * *



* * *

🔁 二、插入类算法
----------

### 3️⃣ 直接插入排序（Insertion Sort）

**思路：**

*   把数组看作“已排序区 + 未排序区”。
*   每次从未排序区取一个数，插入到已排序区的合适位置。

**例子：**

```
初始: [3, 1, 4, 2]
第一步: [1, 3, 4, 2]
第二步: [1, 3, 4, 2]
第三步: [1, 2, 3, 4]
```

**复杂度：**

*   平均/最坏：O(n²)
*   最好：O(n)（已排序时）
*   稳定 ✅
*   对小规模或部分有序数据非常高效。

#### 实例

直接插入排序（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

### 算法原理



1. **初始状态**：将数组的第一个元素视为已排序序列，其余元素视为未排序序列。
2. **迭代过程**：从第二个元素开始，遍历未排序序列中的每一个元素（设为 `key`）。
3. **查找并移动**：
   - 将 `key` 与已排序序列中的元素从后向前依次比较。
   - 如果已排序元素大于 `key`，则将该元素向后移动一位，为 `key` 腾出位置。
4. **插入**：直到找到一个不大于 `key` 的元素，或者已到达已排序序列的起点，然后将 `key` 插入到这个位置。
5. **重复**：重复步骤 2-4，直到所有元素都插入到已排序序列中。



### C++ 代码实现



以下是使用 C++ 实现直接插入排序的示例代码：

C++

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // 包含 std::swap 或 std::move

// 使用 std::vector 实现插入排序
void insertionSort(std::vector<int>& arr) {
    int n = arr.size();
    
    // 从第二个元素开始遍历（第一个元素视为已排序）
    for (int i = 1; i < n; ++i) {
        // key 是当前需要插入到已排序部分的元素
        int key = arr[i];
        int j = i - 1; // 已排序部分的最后一个元素的索引

        // 循环向左查找 key 的插入位置
        // 条件：j >= 0 确保不越界，arr[j] > key 确保元素需要后移
        while (j >= 0 && arr[j] > key) {
            // 将大于 key 的元素向右移动一位
            arr[j + 1] = arr[j];
            j = j - 1;
        }

        // 插入 key 到正确的位置 (j + 1)
        arr[j + 1] = key;
    }
}

// 示例：使用数组实现的版本（对于固定大小的C风格数组或传入指针和大小）
void insertionSortArray(int arr[], int n) {
    for (int i = 1; i < n; ++i) {
        int key = arr[i];
        int j = i - 1;

        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}

// 打印数组或向量的辅助函数
void printArray(const std::vector<int>& arr) {
    for (int x : arr) {
        std::cout << x << " ";
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> data = {12, 11, 13, 5, 6};

    std::cout << "原始数据: ";
    printArray(data);

    insertionSort(data);

    std::cout << "排序结果: ";
    printArray(data);

    return 0;
}
```



### 复杂度分析

- **时间复杂度**：
  - **最好情况**：$O(n)$（数组已经有序，内层循环几乎不执行）
  - **最坏情况**：$O(n^2)$（数组逆序）
  - **平均情况**：$O(n^2)$
- **空间复杂度**：$O(1)$（只需要常数级的额外空间存储 `key`）
- **稳定性**：**稳定**。如果两个相等的元素，在排序前后的相对位置保持不变，那么排序算法是稳定的。插入排序中，当 `arr[j] > key` 时才移动元素，对于等于 `key` 的元素，它会停在 `key` 的左边，从而保持了相对顺序。

* * *

### 4️⃣ 希尔排序（Shell Sort）

**思路：**

*   是“插入排序”的改进版。
*   先把元素分成若干个间隔为 `gap` 的组，组内使用插入排序；
*   再逐步缩小 `gap`，直到 gap=1 完成整体排序。

**例子：**

```
[8, 3, 7, 4, 2, 6]
gap=3 → 分组排序 → gap=1 → 完成
```

**复杂度：**

*   平均：O(n^(1.3~1.5))
*   不稳定 ❌
*   实际速度远快于 O(n²)。

* * *

⚙️ 三、选择类算法
----------

### 5️⃣ 选择排序（Selection Sort）

**思路：**

*   每次从未排序区选择最小（或最大）的元素，
*   放到已排序区的末尾。

**例子：**

```
[5, 2, 4, 1, 3]
第一轮选1 → [1, 2, 4, 5, 3]
第二轮选2 → [1, 2, 4, 5, 3]
……
```

**复杂度：**

*   所有情况：O(n²)
*   不稳定 ❌
*   优点：交换次数少（最多 n-1 次）。

#### 实例

希尔排序（Shell Sort）是一种基于**插入排序**的**非稳定**、**原地**排序算法。它通过比较相距一定间隔（称为“增量”或“步长”，英文是 *gap*）的元素来工作，从而能让离最终位置很远的元素“一步到位”，比普通的插入排序效率更高。

以下是在 C++ 中实现希尔排序的基本方法和步骤：



### 算法步骤



希尔排序可以概括为以下几个步骤：

1. 选择增量序列（Gap Sequence）：

   选择一个递减的增量序列 $h_k, h_{k-1}, \dots, h_1$，其中 $h_1 = 1$。常见的增量序列是 $N/2, N/4, \dots, 1$（$N$ 是数组长度），或者使用 Knuth, Sedgewick 等人提出的更优序列。

2. 分组进行插入排序（Gapped Insertion Sort）：

   对于序列中的每个增量 $h$：

   a.  将待排序数组分成若干个子序列，所有间隔为 $h$ 的元素组成一个子序列。

   b.  对每个子序列进行插入排序（称为 $h$-排序）。

3. 递减增量：

   减小增量 $h$，重复步骤 2，直到增量为 $1$。

当增量 $h=1$ 时，整个数组被视为一个子序列，此时进行的就是普通的插入排序，但由于前面大增量的预排序，此时数组已经“几乎有序”，因此最后一步插入排序的效率非常高。



### C++ 实现示例 (使用 $N/2$ 递减序列)



以下是一个使用向量 `std::vector<int>` 实现希尔排序的 C++ 函数示例：

C++

```cpp
#include <vector>
#include <iostream>
#include <algorithm> // 包含 std::swap, 但这里直接使用临时变量实现原地交换/移动

void shellSort(std::vector<int>& arr) {
    int n = arr.size();

    // 1. 选择增量序列并递减，这里使用 Knuth/Shell 推荐的 n/2 序列
    for (int gap = n / 2; gap > 0; gap /= 2) {
        // 2. 进行 gapped 插入排序
        // i 从 gap 开始，遍历所有元素
        for (int i = gap; i < n; i++) {
            // temp 存储当前元素 arr[i]，用于插入
            int temp = arr[i];
            int j;

            // 3. 对间隔为 gap 的元素进行插入排序（在一个子序列内）
            // 将 arr[i] 插入到已排序的子序列 arr[i-gap], arr[i-2*gap], ... 中
            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                // 后移元素，为 temp 腾出位置
                arr[j] = arr[j - gap];
            }

            // 将 temp 插入到正确位置
            arr[j] = temp;
        }
    }
}

// 示例用法
/*
int main() {
    std::vector<int> data = {12, 34, 54, 2, 3};
    std::cout << "Original array: ";
    for (int x : data) std::cout << x << " ";
    std::cout << std::endl;

    shellSort(data);

    std::cout << "Sorted array: ";
    for (int x : data) std::cout << x << " ";
    std::cout << std::endl;

    return 0;
}
*/
```



### 关键点解析



1. **外层循环 `for (int gap = n / 2; gap > 0; gap /= 2)`**：控制增量（步长）的递减。这是希尔排序的核心。
2. **第二层循环 `for (int i = gap; i < n; i++)`**：类似于插入排序的循环，但它从第 `gap` 个元素开始，确保可以向前回溯 `gap` 步。
3. **内层循环 `for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)`**：这是**带增量的插入排序**逻辑。它不是比较相邻元素，而是比较相距 `gap` 的元素 (`arr[j - gap]` 和 `temp`)，并执行相应的移动（`arr[j] = arr[j - gap]`）来为 `temp` 腾出位置。

希尔排序的**时间复杂度**取决于所选的增量序列。对于最优的增量序列，其平均时间复杂度可以达到 $O(n^{1.3})$ 甚至接近 $O(n \log^2 n)$，优于普通插入排序的 $O(n^2)$。**空间复杂度**为 $O(1)$（原地排序）。





* * *

### 6️⃣ 堆排序（Heap Sort）

**思路：**

*   把数组构造成一个大顶堆；
*   每次取出堆顶（最大值），与末尾交换；
*   再调整堆结构。

**例子：**

```
构造大顶堆：[9, 6, 7, 3, 2]
取9放末尾，重新堆化
→ [7, 6, 3, 2, 9]
```

**复杂度：**

*   平均/最坏：O(n log n)
*   不稳定 ❌
*   不需额外空间，性能稳定。



#### 介绍：

✅ 一、什么是大顶堆
----------

> 大顶堆（Max Heap）是一种完全二叉树，满足以下条件：
>
> 1.  每个结点的值都 **大于等于其子节点** 的值。
> 2.  树是 **完全二叉树**（即除了最后一层外，每一层都是满的，最后一层的节点尽量靠左）。

堆常用于实现优先队列、堆排序等算法。

* * *

✅ 二、示例代码
--------

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 调整函数：维护以 i 为根的子树的大顶堆性质
void heapify(vector<int>& arr, int n, int i) {
    int largest = i;          // 假设当前节点 i 是最大值
    int left = 2 * i + 1;     // 左子节点下标
    int right = 2 * i + 2;    // 右子节点下标

    // 如果左子节点存在且比当前最大值还大
    if (left < n && arr[left] > arr[largest])
        largest = left;

    // 如果右子节点存在且比当前最大值还大
    if (right < n && arr[right] > arr[largest])
        largest = right;

    // 如果最大值不是根节点，交换并递归调整
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);  // 递归调整子树
    }
}

// 构建大顶堆
void buildMaxHeap(vector<int>& arr) {
    int n = arr.size();
    // 从最后一个非叶子节点开始，往上调整
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
}

int main() {
    vector<int> arr = {3, 5, 1, 10, 2, 7};

    cout << "原数组: ";
    for (int x : arr) cout << x << " ";
    cout << endl;

    buildMaxHeap(arr);

    cout << "构建后的大顶堆: ";
    for (int x : arr) cout << x << " ";
    cout << endl;

    return 0;
}
```

* * *

✅ 三、逐行逻辑详解
----------

### `heapify()` 函数 —— 保持堆的性质

```cpp
void heapify(vector<int>& arr, int n, int i)
```

*   `arr`: 存放堆元素的数组。
*   `n`: 当前堆的大小。
*   `i`: 当前要调整的节点下标。

* * *

```cpp
int largest = i;
int left = 2 * i + 1;
int right = 2 * i + 2;
```

*   用数组模拟二叉树时：
    *   父节点下标为 `i`；
    *   左子节点为 `2*i + 1`；
    *   右子节点为 `2*i + 2`。
*   先假设当前节点 `i` 是最大值。

* * *

```cpp
if (left < n && arr[left] > arr[largest])
    largest = left;
```

*   如果左子节点存在（`left < n`）且比当前最大值大，则更新最大下标。

* * *

```cpp
if (right < n && arr[right] > arr[largest])
    largest = right;
```

*   同理检查右子节点。

* * *

```cpp
if (largest != i) {
    swap(arr[i], arr[largest]);
    heapify(arr, n, largest);
}
```

*   如果最大值不是当前节点 `i`，说明违反了堆的性质。
*   交换两者的位置。
*   递归调整被交换的子节点，保证整个子树仍然满足堆的性质。

* * *

### `buildMaxHeap()` 函数 —— 构造堆

```cpp
void buildMaxHeap(vector<int>& arr)
```

*   从数组底部开始构造大顶堆。

* * *

```cpp
int n = arr.size();
for (int i = n / 2 - 1; i >= 0; i--) {
    heapify(arr, n, i);
}
```

*   为什么从 `n/2 - 1` 开始？
    *   因为下标从 `n/2` 到 `n-1` 的节点都是叶子节点，不需要调整。
    *   从最后一个非叶子节点开始，逐步往上保证每棵子树都是堆。
*   调用 `heapify` 逐步“下沉”节点，最终整个数组成为大顶堆。

* * *

### `main()` 函数部分

```cpp
vector<int> arr = {3, 5, 1, 10, 2, 7};
```

*   原数组并不满足堆的性质。

* * *

```cpp
buildMaxHeap(arr);
```

*   调用函数完成堆构造。

* * *

```cpp
输出：
原数组: 3 5 1 10 2 7
构建后的大顶堆: 10 5 7 3 2 1
```

*   结果表明堆的根节点（`arr[0]`）是最大值 10。
*   同时，堆的每个子树也满足“父节点 ≥ 子节点”的性质。

* * *

✅ 四、扩展：堆排序
----------

在堆构建完成后，可以通过不断将堆顶（最大值）取出并重建堆，实现 **堆排序**。

```cpp
void heapSort(vector<int>& arr) {
    buildMaxHeap(arr);
    for (int i = arr.size() - 1; i > 0; i--) {
        swap(arr[0], arr[i]);        // 将堆顶元素（最大）放到数组末尾
        heapify(arr, i, 0);          // 重新调整剩余部分
    }
}
```

* * *

✅ 五、总结
------

| 步骤             | 操作             | 作用             |
| ---------------- | ---------------- | ---------------- |
| `heapify()`      | 向下调整         | 保持局部堆的性质 |
| `buildMaxHeap()` | 从底向上调整     | 构造整个堆       |
| `heapSort()`     | 反复取出堆顶元素 | 完成排序         |

* * *

🧮 四、分治类算法
----------

### 7️⃣ 归并排序（Merge Sort）

**思路：**

*   把数组不断二分，直到子数组长度为1；
*   再将两个有序子数组合并为一个有序数组。

**例子：**

```
[4, 2, 5, 1, 3]
拆分 → [4,2,5] 和 [1,3]
合并 → [1,2,3,4,5]
```

**复杂度：**

*   平均/最坏：O(n log n)
*   稳定 ✅
*   需要额外 O(n) 空间



#### 细节：

✅ 一、算法原理
--------

**归并排序的思想：**

1.  **分解（Divide）**  
    把数组从中间分成两半。
2.  **递归排序（Conquer）**  
    对每一半递归调用归并排序。
3.  **合并（Combine）**  
    把两个有序数组合并成一个新的有序数组。

整个过程形成一棵“递归树”，时间复杂度为

$$
O(n \log n)
$$

稳定性良好，常用于处理大规模数据。

* * *

✅ 二、完整代码
--------

```cpp
#include <iostream>
#include <vector>
using namespace std;

// ------------------------------
// 合并两个有序子数组的函数
// ------------------------------
void merge(vector<int>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;      // 左半部分长度
    int n2 = right - mid;         // 右半部分长度

    // 创建两个临时数组
    vector<int> L(n1), R(n2);

    // 将数据分别拷贝到临时数组中
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];

    // 三个指针：i 遍历左半，j 遍历右半，k 写入原数组
    int i = 0, j = 0, k = left;

    // 逐个比较左右数组的元素，按升序放回 arr
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {       // 若左边更小或相等，放左边
            arr[k] = L[i];
            i++;
        } else {                  // 否则放右边
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // 把左半部分剩余的元素复制回去
    while (i < n1) {
        arr[k] = L[i];
        i++; k++;
    }

    // 把右半部分剩余的元素复制回去
    while (j < n2) {
        arr[k] = R[j];
        j++; k++;
    }
}

// ------------------------------
// 递归实现归并排序的函数
// ------------------------------
void mergeSort(vector<int>& arr, int left, int right) {
    if (left < right) {  // 递归终止条件
        int mid = left + (right - left) / 2; // 避免(left+right)溢出

        // 对左右两半分别排序
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);

        // 合并两个有序的子数组
        merge(arr, left, mid, right);
    }
}

int main() {
    vector<int> arr = {38, 27, 43, 3, 9, 82, 10};

    cout << "原始数组: ";
    for (int x : arr) cout << x << " ";
    cout << endl;

    mergeSort(arr, 0, arr.size() - 1);

    cout << "排序后数组: ";
    for (int x : arr) cout << x << " ";
    cout << endl;

    return 0;
}
```

* * *

✅ 三、逐行逻辑详细讲解
------------

### 🔹 主体结构

```cpp
mergeSort(arr, 0, arr.size() - 1);
```

调用归并排序，从下标 `0` 到 `n-1` 排序整个数组。

* * *

### 🔹 `mergeSort()`：递归分治核心

```cpp
if (left < right)
```

*   递归终止条件：当 `left == right` 时，区间内只有一个元素，已经有序。

* * *

```cpp
int mid = left + (right - left) / 2;
```

*   计算中点，分成 `[left, mid]` 和 `[mid+1, right]`。
*   这样写避免 `(left + right)` 可能的整数溢出。

* * *

```cpp
mergeSort(arr, left, mid);
mergeSort(arr, mid + 1, right);
```

*   分别递归排序左半部分和右半部分。

* * *

```cpp
merge(arr, left, mid, right);
```

*   最后把两个有序的部分“合并”成一个有序整体。

* * *

### 🔹 `merge()`：合并两个有序子数组

假设我们现在有两个已排好序的部分：

```
左半部分：arr[left ... mid]
右半部分：arr[mid+1 ... right]
```

* * *

```cpp
int n1 = mid - left + 1;
int n2 = right - mid;
```

*   分别计算左右子数组的长度。

* * *

```cpp
vector<int> L(n1), R(n2);
```

*   新建两个临时数组存放左右部分。

* * *

```cpp
for (int i = 0; i < n1; i++)
    L[i] = arr[left + i];
for (int j = 0; j < n2; j++)
    R[j] = arr[mid + 1 + j];
```

*   把原数组中的左右部分拷贝到临时数组中，方便比较。

* * *

```cpp
int i = 0, j = 0, k = left;
```

*   `i` 指向左数组 `L`
*   `j` 指向右数组 `R`
*   `k` 指向合并后写回的 `arr` 的位置

* * *

```cpp
while (i < n1 && j < n2)
```

*   只要左右两边都还有元素，就继续比较。

* * *

```cpp
if (L[i] <= R[j]) {
    arr[k] = L[i];
    i++;
} else {
    arr[k] = R[j];
    j++;
}
k++;
```

*   把较小的数放进 `arr[k]`。
*   保证结果仍然是升序排列。
*   因为 `<=` 使用的是“<=”，所以**归并排序是稳定的排序算法**。

* * *

```cpp
while (i < n1)
    arr[k++] = L[i++];
while (j < n2)
    arr[k++] = R[j++];
```

*   把剩余元素（只可能在某一边）直接复制回原数组。

* * *

### 🔹 `main()` 函数输出

```cpp
原始数组: 38 27 43 3 9 82 10
排序后数组: 3 9 10 27 38 43 82
```

* * *

✅ 四、可视化理解
---------

以下是归并排序的过程（以 `[38,27,43,3]` 为例）：

```
[38,27,43,3]
   ↓分割
[38,27]    [43,3]
 ↓          ↓
[38] [27]   [43] [3]
 ↓合并      ↓合并
[27,38]     [3,43]
     ↓再合并
   [3,27,38,43]
```

* * *

✅ 五、算法特性总结
----------

| 特性       | 描述                                     |
| ---------- | ---------------------------------------- |
| 时间复杂度 | **O(n log n)**（最坏、平均、最好都一样） |
| 空间复杂度 | **O(n)**（需要额外临时数组）             |
| 稳定性     | ✅ 稳定（相等元素不会交换相对位置）       |
| 适合场景   | 大规模数据排序、链表排序、外部排序       |

* * *





* * *

🔢 五、非比较类算法
-----------

### 8️⃣ 计数排序（Counting Sort）

**思路：**

*   统计每个数出现的次数；
*   通过“计数累加”来确定每个数应放的位置。

**要求：**

*   适用于整数，且数据范围较小。

**例子：**

```
[2, 5, 2, 1]
计数表：1→1次, 2→2次, 5→1次
重构数组：[1, 2, 2, 5]
```

**复杂度：**

*   O(n + k)（k是取值范围）
*   稳定 ✅
*   非比较排序。



* * *

### 9️⃣ 桶排序（Bucket Sort）

**思路：**

*   将数据按区间分到多个“桶”中；
*   各桶内部单独排序；
*   再把桶拼接起来。

**例子：**

```
[0.12, 0.43, 0.23, 0.89]
分桶： [0.1~0.2], [0.2~0.3]...
```

**复杂度：**

*   平均：O(n + k)
*   适合数据分布均匀时。

* * *

### 🔟 基数排序（Radix Sort）

**思路：**

*   按“位”排序（个位、十位、百位…），
*   每次使用稳定的计数排序。

**例子：**

```
[170, 45, 75, 90, 802, 24, 2, 66]
先按个位 → 再按十位 → 再按百位
```

**复杂度：**

*   O(d·(n + k))，d为位数
*   稳定 ✅
*   适合整数或定长字符串。

* * *

📊 六、整体对比总结
-----------

| 算法     | 平均复杂度   | 空间复杂度 | 稳定性 | 思想类型 |
| -------- | ------------ | ---------- | ------ | -------- |
| 冒泡排序 | O(n²)        | O(1)       | ✅      | 交换     |
| 选择排序 | O(n²)        | O(1)       | ❌      | 选择     |
| 插入排序 | O(n²)        | O(1)       | ✅      | 插入     |
| 希尔排序 | O(n^1.5)     | O(1)       | ❌      | 插入改进 |
| 快速排序 | O(n log n)   | O(log n)   | ❌      | 分治     |
| 归并排序 | O(n log n)   | O(n)       | ✅      | 分治     |
| 堆排序   | O(n log n)   | O(1)       | ❌      | 选择改进 |
| 计数排序 | O(n + k)     | O(k)       | ✅      | 非比较   |
| 桶排序   | O(n + k)     | O(n + k)   | ✅      | 非比较   |
| 基数排序 | O(d·(n + k)) | O(n + k)   | ✅      | 非比较   |

* * *

