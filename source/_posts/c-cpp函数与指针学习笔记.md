---
title: c/cpp函数与指针学习笔记
date: 2025-11-09 13:02:23
tags:
  - 大学
  - c
  - cpp
  - 函数
  - 指针
---

# 函数

## 🖥️ C语言函数与C++函数的区别



C语言和C++虽然有很深的渊源，但在函数方面存在一些关键的区别：

- **1. 默认参数 (Default Arguments)**
  - **C++:** **支持** 默认参数。您可以在函数声明时为参数指定一个默认值，调用时如果省略该参数，则使用默认值。
  - **C:** **不支持** 默认参数。
- **2. 函数重载 (Function Overloading)**
  - **C++:** **支持** 函数重载。允许在同一个作用域内定义多个同名函数，只要它们的**参数列表**（参数个数或参数类型）不同即可。
  - **C:** **不支持** 函数重载。C语言中，函数名必须是唯一的。
- **3. 引用参数 (Reference Parameters)**
  - **C++:** **支持** 引用（Reference）。C++允许使用引用作为函数参数，这提供了一种更安全、更简洁的地址传递方式。
  - **C:** **不支持** 引用。C语言只能通过**指针**（Pointer）来实现类似的功能。
- **4. 内联函数 (Inline Functions)**
  - **C++:** **支持** `inline` 关键字。建议编译器将函数体在调用处展开，以减少函数调用开销（但编译器不一定会采纳）。
  - **C:** 通常使用**宏（Macro）**来实现类似内联的功能，但宏在类型检查和安全性方面不如C++的 `inline` 关键字。
- **5. 链接规则 (Linkage)**
  - 当C++代码需要调用C函数或被C代码调用时，需要使用 **`extern "C"`** 来指示编译器以C的方式（不进行函数名修饰/重载支持）来编译或链接该函数，以确保兼容性。C语言没有这个需求。

------



## 🔗 值传递与地址传递/引用传递的区别



在C/C++中，函数参数的传递方式主要有两种：**值传递** 和 **地址传递**（在C++中也常说**引用传递**）。

| **特性**         | **值传递 (Pass by Value)**                              | **地址传递 (Pass by Address/Pointer)**               | **引用传递 (Pass by Reference, C++ Only)** |
| ---------------- | ------------------------------------------------------- | ---------------------------------------------------- | ------------------------------------------ |
| **工作原理**     | 传递实参的**副本**。                                    | 传递实参的**内存地址**（即指针）。                   | 传递实参的**别名**（引用）。               |
| **函数内修改**   | 函数内对参数的修改，**不会**影响实参。                  | 函数内通过解引用修改指针指向的内存，**会**影响实参。 | 函数内对参数的修改，**会**影响实参。       |
| **内存开销**     | 传递复杂类型时，需要复制整个对象/结构体，开销可能较大。 | 只传递地址（一个指针大小），开销小。                 | 只传递地址，开销小。                       |
| **安全性**       | 实参是安全的，不会被修改。                              | 需要小心使用指针，**容易出错**（例如野指针）。       | 更安全、简洁，无需指针的解引用操作。       |
| **C 语言支持**   | ✅ 支持                                                  | ✅ 支持 (使用指针 `*`)                                | ❌ 不支持                                   |
| **C++ 语言支持** | ✅ 支持                                                  | ✅ 支持 (使用指针 `*`)                                | ✅ 支持 (使用引用 `&`)                      |

> **总结：**
>
> - **值传递**：保证实参安全，但不能改变实参，且传递大型对象时效率低。
> - **地址/引用传递**：可以改变实参，且效率高。
> - 在C++中，**引用传递**是比**地址传递**更推荐的方式，因为它更安全、更简洁。

------



## ❓ 要不要用到 `&` (取地址符/引用声明符)



`&` 符号在C/C++中有两种主要的用法，分别对应不同的传递方式：



### 1. 用于 **地址传递** (C/C++)



在这种情况下，`&` 作为**取地址运算符 (Address-of Operator)**，用于获取变量的内存地址。

- **用法示例（C/C++）：**

  C

  ```
  void modify_value_by_pointer(int *p) {
      *p = 20; // 通过指针修改内存中的值
  }
  
  int main() {
      int x = 10;
      // 调用时使用 &x 获取 x 的地址
      modify_value_by_pointer(&x);
      // 此时 x 的值变为 20
      return 0;
  }
  ```

- **结论：** 当您想使用**地址传递**（即通过指针）来修改函数外部的变量时，**需要**在调用函数时使用 `&` 来获取变量的地址。



### 2. 用于 **引用传递** (C++ Only)



在这种情况下，`&` 作为**引用声明符 (Reference Declarator)**，用于声明一个引用类型的变量或参数。

- **用法示例（C++）：**

  C++

  ```
  void modify_value_by_reference(int &r) { // 声明 r 是一个引用参数
      r = 30; // 直接修改引用的值
  }
  
  int main() {
      int x = 10;
      // 调用时直接传入变量 x，无需 & 符号
      modify_value_by_reference(x);
      // 此时 x 的值变为 30
      return 0;
  }
  ```

- **结论：** 当您想使用 **引用传递**（C++特有）来修改函数外部的变量时，**不需要**在调用函数时使用 `&` 符号。`&` 符号仅用于**声明**函数参数是引用类型。



## 重载

## 🔄 什么是重载 (Overloading)



在C++等支持面向对象特性的编程语言中，“**重载 (Overloading)**”是指在**同一作用域**内，允许使用**相同的名称**来定义不同的功能实体。它主要分为两种类型：**函数重载** 和 **运算符重载**。



### 1. 函数重载 (Function Overloading)



函数重载是C++相对于C语言最显著的特性之一。



#### **定义**



**函数重载**允许您定义多个名称相同但**参数列表不同**的函数。当调用这个函数名时，编译器会根据传入的参数类型和数量来决定调用哪一个具体的函数。



#### **核心规则**



要构成函数重载，同名函数必须满足以下条件之一：

- **参数个数不同**。
- **参数类型不同**。
- **参数顺序不同**（如果参数类型不止一种）。

> ⚠️ **注意：** 函数的**返回类型**不同，**不能**构成重载！编译器只通过参数列表来区分函数。



#### **目的与优势**



- **提高代码的**清晰度和可读性。
- **保持一致性：** 允许对执行相似操作但操作对象不同的函数使用相同的名称，使接口更直观。



#### **C++ 示例**



C++

```
#include <iostream>

// #1：计算两个整数的和
int add(int a, int b) {
    return a + b;
}

// #2：计算两个浮点数的和 (与 #1 参数类型不同，构成重载)
double add(double a, double b) {
    return a + b;
}

// #3：计算三个整数的和 (与 #1 参数个数不同，构成重载)
int add(int a, int b, int c) {
    return a + b + c;
}

int main() {
    std::cout << "整数相加: " << add(5, 10) << std::endl;     // 调用 #1
    std::cout << "浮点数相加: " << add(5.5, 10.2) << std::endl; // 调用 #2
    std::cout << "三个数相加: " << add(1, 2, 3) << std::endl;   // 调用 #3
    return 0;
}
```

------



### 2. 运算符重载 (Operator Overloading)



运算符重载也是C++的另一个重要特性。



#### **定义**



**运算符重载**允许您重新定义或扩展C++中现有运算符（如 `+`、`-`、`*`、`/`、`==` 等）的功能，使其可以应用于自定义的类（Class）对象。



#### **目的**



使自定义类型的对象能够像内置数据类型一样，使用标准的数学或逻辑运算符进行操作，从而**提高代码的直观性和可读性**。

> **例如：** 您可以重载 `+` 运算符，使得两个名为 `Vector` 的对象可以使用 `Vector c = a + b;` 的方式进行向量加法，而不是必须使用一个复杂的 `c = a.add(b);` 方法。



## C和C++函数返回**数组**或**队列**

## 🖥️ 函数返回数组 (Array)



在C和C++中，**不能直接通过函数返回值返回一个完整的局部数组**。



### 1. C/C++ 为什么不能直接返回局部数组？



这是因为当函数执行完毕后，它内部的**局部变量**（包括局部数组）所占用的栈内存会被释放。如果直接返回这个局部数组，调用函数拿到的将是一个指向**已被释放**内存的指针，这就是著名的**悬空指针**问题，会导致未定义行为。



### 2. 正确的返回数组的方法



虽然不能直接返回局部数组本身，但有几种方法可以实现数组数据的返回：



#### A. 返回指向堆内存的指针 (C/C++)



在函数内部，使用动态内存分配（如C中的 `malloc` 或 C++中的 `new`）在**堆 (Heap)** 上创建数组，然后返回指向该堆内存的**指针**。

- **优点：** 数组在函数结束后仍然存在。
- **缺点：** 必须由调用者负责使用 `free` (C) 或 `delete[]` (C++) 来**手动释放**这块内存，否则会导致**内存泄漏**。



#### B. 传入指针或引用，通过参数修改 (C/C++)



将一个在调用函数中定义的数组的**指针**或**引用**作为参数传入函数，在函数内部通过这个指针/引用来修改外部数组的内容。

- **优点：** 避免了内存管理问题和栈内存限制。



#### C. 返回 `std::array` 或 `std::vector` (C++ **推荐**)



在C++中，应该避免使用原始数组和指针来返回值。**容器**是更好的选择。

- **`std::vector`：** 最灵活的动态数组容器，可以直接作为返回值，返回时会进行值复制（或通过移动语义高效转移所有权）。
- **`std::array`：** 固定大小的数组包装器，也可以直接作为返回值。

------



## 💾 函数返回队列 (Queue) 或其他容器



这里我们主要讨论C++标准模板库 (STL) 中的容器，因为C语言通常不直接支持“队列”这种复杂的数据结构作为返回值（C语言需要自己实现）。



### 1. C++ 返回 STL 容器（推荐做法）



在C++中，函数**可以**直接返回标准容器，如 `std::vector`、`std::queue`、`std::map` 等。

- **示例：**

  C++

  ```
  #include <queue>
  
  std::queue<int> create_and_return_queue() {
      std::queue<int> my_queue;
      my_queue.push(10);
      my_queue.push(20);
      return my_queue; // 直接返回
  }
  
  int main() {
      std::queue<int> result_q = create_and_return_queue();
      // ... 使用 result_q
      return 0;
  }
  ```

- **原理：** 现代C++编译器通常会利用**移动语义 (Move Semantics)** 或 **返回值优化 (RVO/NRVO)**，以极高的效率（接近零开销）完成容器的返回，避免了传统深拷贝的性能损耗。



### 2. C 语言返回队列



在C语言中，如果你自己实现了一个**队列的结构体**（例如，包含头指针和尾指针），你需要返回的是这个**结构体**本身，或者返回一个指向这个**结构体实例**的**指针**（如果这个实例是动态分配在堆上的）。

- **返回结构体：** C语言函数可以直接返回**结构体**（即值复制整个结构体）。
- **返回结构体指针：** 如果结构体内部包含动态分配的内存，或者结构体较大，通常会返回指向堆上分配的结构体的**指针**。

------

**总结表格：**

| **数据类型**      | **C 语言**     | **C++ 语言**   | **推荐做法**                       |
| ----------------- | -------------- | -------------- | ---------------------------------- |
| **原始数组**      | ❌ 不能直接返回 | ❌ 不能直接返回 | 传入指针修改，或返回 `std::vector` |
| **`std::vector`** | ❌ 不支持       | ✅ 可以直接返回 | **直接返回**（利用RVO/移动语义）   |
| **`std::queue`**  | ❌ 不支持       | ✅ 可以直接返回 | **直接返回**（利用RVO/移动语义）   |
| **结构体**        | ✅ 可以直接返回 | ✅ 可以直接返回 | **直接返回**或返回智能指针         |



## 数组引用

## 1. 允许修改数组内容的方法 (可写)



如果您希望函数能够修改原始数组中的元素，您只需正常地将数组传递给函数即可。



### 📌 核心原理



因为传递的是数组的**起始地址（指针）**，函数内部通过这个地址对数组元素的修改，会直接反映到调用函数中定义的原始数组上。



### 💻 示例代码



C

```
#include <stdio.h>

// 函数声明：可以使用指针或数组符号，效果相同
// void modify_array(int *arr, int size)
void modify_array(int arr[], int size) {
    printf("--- 正在修改数组 ---\n");
    for (int i = 0; i < size; i++) {
        // 修改原始内存地址上的值
        arr[i] = arr[i] * 2; 
    }
}

int main() {
    int scores[] = {1, 2, 3, 4, 5};
    int size = sizeof(scores) / sizeof(scores[0]);

    printf("修改前: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", scores[i]); // 输出: 1 2 3 4 5
    }
    printf("\n");

    // 调用函数，数组名 'scores' 退化为指向第一个元素的指针
    modify_array(scores, size); 

    printf("修改后: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", scores[i]); // 输出: 2 4 6 8 10
    }
    printf("\n");

    return 0;
}
```

------



## 2. 不允许修改数组内容的方法 (只读)



如果您希望函数只读取数组内容，并防止函数体内的代码意外修改原始数组，您应该使用 `const` 关键字。



### 📌 核心原理



在函数参数的声明中添加 `const` 关键字，表示这个指针所指向的**内容是常量**（Constant Data）。

- **编译器强制保护：** 如果函数内部尝试修改 `const` 修饰的数组元素，编译器将立即报错。
- **清晰的接口：** 告诉调用者和维护者，这个函数不会对数组进行任何写操作。



### 💻 示例代码



C

```
#include <stdio.h>

// 函数声明：使用 const 关键字
void print_array(const int arr[], int size) {
    printf("--- 正在打印数组 ---\n");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    // !!! 错误示范：如果尝试修改，编译器会报错 !!!
    // arr[0] = 99; // 编译错误: assignment of read-only location
}

int main() {
    int data[] = {10, 20, 30};
    int size = sizeof(data) / sizeof(data[0]);

    // 调用函数，函数内只能读取 data
    print_array(data, size); 
    
    // 原始数组 data 保持不变
    printf("主函数中第一个元素: %d\n", data[0]); // 输出: 10

    return 0;
}
```

------



## 💡 C 语言传递数组的最佳实践总结



1. **数组退化为指针：** 无论你写 `int arr[]` 还是 `int *arr` 作为参数，在函数内部它们都是一样的，都是指向数组第一个元素的指针。
2. **必须传递大小：** 由于数组退化为指针，函数内部无法使用 `sizeof(arr)` 来获取数组的总字节数。因此，**总是**应该将数组的大小作为一个单独的 `int` 参数传递给函数。
3. **使用 `const` 保护：** 对于所有只读操作的函数，请务必使用 `const` 来保护数组内容。



# 指针

## 基础认知

## 📍 什么是指针 (Pointer)?



指针本质上是一种**变量**，但它存储的不是普通的数据值（如整数或字符），而是另一个变量在计算机内存中的**地址 (Memory Address)**。

你可以把计算机内存想象成一排带编号的储物柜，每个柜子都能存放数据。

- **普通变量**：存放的是储物柜里的**物品**（数据值）。
- **指针变量**：存放的是储物柜的**编号**（内存地址）。



### 核心概念与符号



| **概念**     | **含义**                                                   | **符号**       | **示例**                          |
| ------------ | ---------------------------------------------------------- | -------------- | --------------------------------- |
| **指针变量** | 一种特殊的变量，**存储地址**。                             | `*` 在声明时   | `int *p;` (p是一个指向整数的指针) |
| **取地址**   | 获取一个普通变量在内存中的实际位置。                       | `&` (取地址符) | `p = &a;` (将变量a的地址存入p)    |
| **解引用**   | 通过指针存储的地址，访问或修改该地址处存放的**实际数据**。 | `*` (解引用符) | `*p = 20;` (通过p修改a的值)       |



### 📝 示例：指针的工作原理



假设内存中有一个整数变量 `a`，它的值是 `10`，并且它存储在内存地址 `0x7ffe01`（这是一个假设的地址）。

1. **定义普通变量：**

   C

   ```
   int a = 10;
   ```

   - **内存情况：** 地址 `0x7ffe01` 存储了值 `10`。

2. **定义指针并取地址：**

   C

   ```
   int *p;    // 声明一个指向int类型的指针变量 p
   p = &a;    // 将变量 a 的地址（0x7ffe01）赋给指针 p
   ```

   - **内存情况：** 指针 `p` 存储了值 `0x7ffe01`。

3. **解引用操作：**

   C

   ```
   printf("%d", *p); // 输出 *p (即地址 0x7ffe01 处的值)，结果为 10
   *p = 20;          // 通过 p 访问 a 的位置，并将 a 的值改为 20
   ```

   - **内存情况：** 地址 `0x7ffe01` 存储的值现在变为 `20`。



## 🌟 为什么需要使用指针？



指针是C/C++语言强大和灵活性的来源，主要用于以下几个方面：

1. **实现地址传递（修改外部变量）：**
   - 通过将变量的地址传递给函数，函数内部可以修改外部变量的值。（正如我们之前讨论的地址传递）
2. **动态内存管理：**
   - 使用 `malloc`/`free` (C) 或 `new`/`delete` (C++) 在**堆**上动态分配内存。这些函数返回的就是指向新分配内存块的**指针**。
3. **高效处理数组和字符串：**
   - 数组名在很多情况下会被当作指向其第一个元素的指针。使用指针进行数组遍历通常比使用下标更快。
4. **实现复杂数据结构：**
   - 如链表、树、图等，这些结构都依赖于指针来连接各个节点。
5. **函数指针：**
   - 指针甚至可以存储函数的地址，从而实现函数的回调等高级功能。



## 指针相关疑问

## 1. C++ 指针一定要是 `int` 吗？



❌ **不，C++ 指针不一定要是 `int` 类型。**

指针变量的类型（例如 `int*`、`char*`、`float*` 等）表示该指针**指向**的数据类型，而不是指针自身存储的值的类型。



### 指针类型与用途



指针的类型（如 `int*`）有两大重要作用：

1. **确定解引用的字节数：** 当您使用解引用操作符 `*` 访问指针指向的数据时，编译器需要知道要从内存中读取多少个字节。
   - `int*`：读取 $4$ 个字节（在多数现代系统中）。
   - `char*`：读取 $1$ 个字节。
   - `double*`：读取 $8$ 个字节。
2. **指针算术的步长：** 当您对指针进行加减运算（例如 `ptr++`）时，指针移动的字节数由其类型决定。
   - `int*` 指针加 $1$，地址增加 $4$ 字节。
   - `char*` 指针加 $1$，地址增加 $1$ 字节。

| **指针类型** | **指向的数据类型** | **什么时候用？**                                             |
| ------------ | ------------------ | ------------------------------------------------------------ |
| `int*`       | 整数               | 指向整数变量或整数数组时。                                   |
| `char*`      | 字符               | 指向字符变量或字符串（字符数组）时。                         |
| `float*`     | 浮点数             | 指向浮点数变量时。                                           |
| `void*`      | **不确定类型**     | 用于函数参数（如 `malloc`、`qsort`）或存储通用地址时。`void*` 不能直接解引用，必须先转换成具体类型的指针。 |

------



## 2. 为什么地址值有非整数符号 `x`？



您看到的带有 `x` 的值，如 `0x7ffe01`，是指针变量存储的**内存地址**。

- **地址是整数：** 从本质上讲，内存地址是计算机用来定位存储位置的**无符号整数**。
- **使用十六进制（Hexadecimal）：** 虽然地址是整数，但程序猿通常使用**十六进制**来表示它们，因为十六进制更紧凑，并且能更方便地映射到计算机的二进制和字节结构。
- **`0x` 的含义：** 在C/C++中，任何以 `0x` 开头的值都表示它是一个**十六进制数**。
  - 例如，十进制的 $255$ 用十六进制表示就是 `0xFF`。

所以，指针存储的是一个巨大的无符号整数，我们只是习惯于用带有 `0x` 前缀的十六进制形式来观察它。

------



## 3. 如何在 `printf` 中输出指针？



在C和C++中使用 `printf` 打印指针变量存储的地址时，应该使用专门的格式说明符：**`%p`**。



### 使用 `%p`



`%p` 格式说明符的作用是将指针变量的值（内存地址）以**十六进制**的形式输出。

| **符号** | **作用**             |
| -------- | -------------------- |
| **`%p`** | 打印指针变量的地址。 |



### 💻 示例代码



C

```
#include <stdio.h>

int main() {
    int num = 42;
    int *ptr_int = &num;        // 指向 int 变量的指针

    char c = 'A';
    char *ptr_char = &c;        // 指向 char 变量的指针

    // 使用 %p 打印指针变量 ptr_int 存储的地址
    printf("num 的地址 (int*): %p\n", (void*)ptr_int);

    // 使用 %p 打印指针变量 ptr_char 存储的地址
    printf("c 的地址 (char*): %p\n", (void*)ptr_char);

    return 0;
}
```

> **重要提示：** C标准要求，当使用 `%p` 格式说明符时，对应的参数必须是类型 `void*`。因此，最佳实践是对任何类型的指针（例如 `int*` 或 `char*`）进行**强制类型转换**到 `(void*)`，以确保代码的兼容性和健壮性。



## 指针运算

指针算术运算是C和C++语言中最强大也是最容易混淆的特性之一。它的工作方式与普通的整数算术运算**有本质区别**，因为它考虑了指针所指向数据类型的大小。



## ⚙️ 核心原理：类型决定步长



指针的算术运算并不是简单地将内存地址加 1 或减 1 个字节。相反，它是根据指针所指向的**数据类型的大小（`sizeof(type)`）**来移动的。

**规则：** 当对某一类型的指针进行加减 N 操作时，指针的地址实际移动的字节数是：

N×sizeof(指向的数据类型)



### 💻 示例说明



假设在一个 64 位系统上：`int` 占 4 字节，`double` 占 8 字节。

C++

```
#include <iostream>

int main() {
    int arr_int[3] = {10, 20, 30};
    int* ptr_int = arr_int; // 指向 arr_int[0]

    double arr_double[3] = {1.1, 2.2, 3.3};
    double* ptr_double = arr_double; // 指向 arr_double[0]

    std::cout << "--- int* 指针算术 (步长: 4 字节) ---\n";
    std::cout << "初始地址: " << (void*)ptr_int << "\n";

    // ptr_int + 1
    ptr_int++; 
    // 地址增加 1 * sizeof(int) = 4 字节
    std::cout << "ptr_int + 1: " << (void*)ptr_int << "\n"; 
    
    // ptr_int + 2
    ptr_int += 2; 
    // 地址增加 2 * sizeof(int) = 8 字节
    std::cout << "ptr_int + 3: " << (void*)ptr_int << "\n"; 
    
    std::cout << "\n--- double* 指针算术 (步长: 8 字节) ---\n";
    std::cout << "初始地址: " << (void*)ptr_double << "\n";

    // ptr_double + 1
    ptr_double++; 
    // 地址增加 1 * sizeof(double) = 8 字节
    std::cout << "ptr_double + 1: " << (void*)ptr_double << "\n"; 
    
    return 0;
}
// 注意：打印地址时使用 (void*) 转换是 C++ 打印指针的最佳实践。
```

------



## 📝 支持的指针算术运算



指针算术主要支持以下四种运算：



### 1. 指针加整数 (`ptr + N`)



- **作用：** 将指针向前移动 N 个**元素**的位置。
- **结果：** 得到一个指向新位置的指针。
- **等价关系：** `*(ptr + N)` 等价于 `ptr[N]`。



### 2. 指针减整数 (`ptr - N`)



- **作用：** 将指针向后移动 N 个**元素**的位置。
- **结果：** 得到一个指向新位置的指针。



### 3. 指针相减 (`ptr1 - ptr2`)



- **限制：** 只能对**同类型**的指针进行相减操作，且这两个指针通常应该指向**同一个数组**的不同元素。
- **作用：** 计算两个指针之间相隔的**元素个数**。
- **结果：** 得到一个整数值，类型通常是 `ptrdiff_t`。

C++

```
int arr[5] = {0};
int* p1 = &arr[4]; // 指向最后一个元素
int* p2 = &arr[1]; // 指向第二个元素

ptrdiff_t diff = p1 - p2; // 结果是 3 (相隔 3 个元素：arr[1]、arr[2]、arr[3])
```



### 4. 指针比较 (`ptr1 > ptr2`, `ptr1 == ptr2`, etc.)



- **限制：** 只能对**同类型**的指针进行比较，且它们通常应该指向同一个数组。
- **作用：** 比较两个地址的大小，判断哪个元素在内存中排在前面。

------



## ⚠️ 重要的限制与陷阱



1. **非数组对象：** 指针算术主要为操作**数组**而设计。对非数组对象（即单个变量）的指针进行加减运算是合法的，但通常**没有实际意义**，并且 `ptr + N`（当 N=0）可能会导致指针指向未分配给程序的内存，引发**未定义行为**。
2. **`void\*` 的限制：** **不允许**对 `void*` 类型的指针进行算术运算（C++标准），因为编译器不知道 `void*` 指向的数据类型大小，无法确定步长。
   - *注意：C语言允许对 `void\*` 进行算术运算，但通常将其步长视为 1 字节，这是不推荐且不跨平台的。*
3. **指针相加：** **不允许**指针相加（`ptr1 + ptr2`）。两个地址相加在逻辑上没有意义。
4. **越界访问：** 指针可以指向数组边界之外的一个位置（称为**尾后指针**），但**不能**对其进行解引用操作，否则会导致程序崩溃或未定义行为。



## 💡 实际应用：数组遍历



指针算术最常见的用途是高效地遍历数组。

C++

```cpp
int data[] = {10, 20, 30, 40};
int size = 4;

// 使用指针算术进行遍历
for (int* p = data; p < data + size; ++p) {
    std::cout << *p << " ";
}
// 输出: 10 20 30 40
```



## 1. C 风格数组 (指针) 的移动步长



对于C风格数组，我们使用原始指针（如 `int*`、`double*`）进行算术运算。编译器正是依靠这个**指针类型**来计算步长。



### 核心机制：`sizeof(type)`



当编译器看到 `ptr++` 或 `ptr--` 时，它执行的操作是：

$$\text{新地址} = \text{旧地址} \pm 1 \times \text{sizeof}(\text{指针指向的类型})$$

| **数组类型** | **指针类型** | **步长（sizeof）** | **移动几格**            |
| ------------ | ------------ | ------------------ | ----------------------- |
| `int[]`      | `int*`       | 4 字节             | 移动 1 个 `int` 元素    |
| `double[]`   | `double*`    | 8 字节             | 移动 1 个 `double` 元素 |
| `char[]`     | `char*`      | 1 字节             | 移动 1 个 `char` 元素   |

**结论：** 对于原始指针，`++` 总是移动 $1$ 个**元素**的内存大小，而不是 $1$ 个字节。

------



## 2. C 风格二维数组的移动步长



C风格二维数组的指针算术稍复杂，但原理相同：步长是**行**的大小。



### 核心机制：指向数组的指针



假设有一个 `int arr[5][10]` 的数组，它有 $5$ 行，$10$ 列。

- `int (*ptr)[10] = arr;` (`ptr` 是一个指向包含 $10$ 个整数的数组的指针)。

当执行 ptr++ 时，编译器计算的步长是：



$$\text{步长} = 1 \times \text{sizeof}(\text{一整行}) = 1 \times (10 \times \text{sizeof}(int)) = 40 \text{ 字节}$$

**结论：** 当对指向 $N$ 个元素的数组的指针进行 `++` 操作时，指针会跳过**一整行** $N$ 个元素。

------



## 3. `std::vector` 和 `std::vector` 二维数组的移动步长



对于C++的STL容器 (`std::vector`、`std::list` 等)，我们通常不直接操作原始指针，而是使用**迭代器 (Iterators)**。



### 核心机制：迭代器重载 `operator++`



迭代器是一种**行为像指针的对象**。当您对一个 `std::vector` 的迭代器执行 `++` 或 `--` 时，您实际调用的是 `std::vector::iterator` 类中**重载的 `operator++` 函数**。

- **`std::vector` 的迭代器：** 由于 `std::vector` 的元素在内存中是**连续存储**的，它的迭代器通常在内部实现为一个**原始指针**。因此，它的 `operator++` 内部逻辑与原始指针的 `++` 运算**完全相同**。
  - `std::vector<int>::iterator` 的 `++` 移动 `sizeof(int)` 字节。
- **`std::vector` 的二维数组 (`std::vector<std::vector<int>>`)：**
  - **外层迭代器：** `std::vector<std::vector<int>>::iterator` 指向**一个完整的内层 `vector` 对象**。它的 `++` 移动的是一个 `std::vector<int>` 对象的大小（通常比较大，包含指针、大小、容量等信息）。
  - **内层迭代器：** 遍历内层元素时，`std::vector<int>::iterator` 的 `++` 移动 `sizeof(int)` 字节。



## 指针数组

## 📚 1. 定义与语法



指针数组的定义方式遵循“先看中间”的原则：



### 语法结构



C++

```
Type* arrayName[Size];
```

- `[Size]`：表示这是一个大小为 `Size` 的**数组**。
- `Type*`：表示这个数组中的每个元素都是一个指向 `Type` 类型的**指针**。



### 💻 示例



C++

```
int* int_pointers[5];    // 这是一个包含 5 个元素的数组，每个元素都是一个 int*（指向整数的指针）。
char* string_pointers[3]; // 这是一个包含 3 个元素的数组，每个元素都是一个 char*（指向字符/字符串的指针）。
```



## 🎯 2. 指针数组的用途



指针数组在C++中最常见的用途是处理**多个字符串**和构建**非规则的二维结构**。



### 用途一：存储多个字符串（最常见）



在C++中，C风格字符串（以空字符 `\0` 结尾的字符数组）通常用 `char*` 指针表示。指针数组可以高效地存储多个字符串的起始地址。

C++

```
char* names[] = {
    "Alice",
    "Bob",
    "Charlie"
};
```

在这个例子中：

- `names[0]` 是一个 `char*`，存储了字符串 "Alice" 的首字符 'A' 的地址。
- `names[1]` 是一个 `char*`，存储了字符串 "Bob" 的首字符 'B' 的地址。



### 用途二：构建不规则的二维数组（锯齿数组/Ragged Array）



如果需要一个二维结构，但每行的长度不同，使用指针数组非常高效。

C++

```
int row1[] = {1, 2, 3};
int row2[] = {4, 5};
int row3[] = {6, 7, 8, 9};

int* jagged_array[] = {
    row1,
    row2,
    row3
};
```

- `jagged_array[0]` 指向 `row1` 的起始地址。
- `jagged_array[1]` 指向 `row2` 的起始地址。



## 💡 3. 如何访问指针数组



访问指针数组需要两个步骤：

1. **访问数组元素：** 使用数组下标 `[]` 访问数组中的一个指针。
2. **解引用指针：** 使用 `*` 运算符访问指针指向的实际数据。



### 💻 访问示例



C++

```
int main() {
    int x = 10;
    int y = 20;

    int* ptr_arr[2] = {&x, &y}; // 指针数组，存储 x 和 y 的地址

    // 步骤 1: 访问第一个元素 (得到 &x)
    int* ptr_to_x = ptr_arr[0]; 

    // 步骤 2: 解引用 (访问 x 的值)
    std::cout << "ptr_arr[0] 指向的值: " << *ptr_arr[0] << std::endl; // 输出 10
    
    // 步骤 3: 通过解引用进行修改
    *ptr_arr[1] = 50; // 修改 y 的值为 50
    std::cout << "y 的新值: " << y << std::endl; // 输出 50

    return 0;
}
```



## 🆚 4. 与“指向数组的指针”的区别（易混淆点）



指针数组经常与**指向数组的指针**混淆。它们是截然不同的类型：

| **特性** | **指针数组 (Array of Pointers)**        | **指向数组的指针 (Pointer to Array)**       |
| -------- | --------------------------------------- | ------------------------------------------- |
| **定义** | `Type* arr[Size];`                      | `Type (*ptr)[Size];`                        |
| **含义** | **是一个** 数组，其中的元素是**指针**。 | **是一个** 指针，它指向一个完整的**数组**。 |
| **类型** | `int*[5]`                               | `int (*)[5]`                                |
| **用途** | 存储一组地址（如多字符串）。            | 用于C风格二维数组的行操作。                 |



## 二维数组与指针数组

## 1. `char* names[] = { "Alice", "Bob", "Charlie" };



这是合法的、正确的声明，它创建了一个**指针数组 (Array of Pointers)**。



### 📌 内存结构与含义



| **方面**     | **描述**                                                     |
| ------------ | ------------------------------------------------------------ |
| **类型**     | `char* []` (指向 `char` 的指针数组)                          |
| **数组内容** | `names` 数组中存储了 $3$ 个元素，每个元素都是一个**内存地址** (`char*`)。 |
| **数据存储** | 字符串字面量 `"Alice"`, `"Bob"`, `"Charlie"` 通常存储在程序的**只读数据区**（或静态区）。 |
| **可修改性** | `names` 数组本身（即那 $3$ 个指针）是可修改的。但是，指针**指向的内容**（字符串字面量）是**不可修改**的（修改会导致未定义行为/运行时错误）。 |
| **大小**     | 数组大小为 $3$ (指针的个数)。整个数组占用的内存是 $3 \times \text{sizeof}(char*)$。 |



### 图示理解



> **names 数组** (在栈上/全局区)
>
> | **索引**   | **值 (地址)** | **指向哪里？ (只读区)** |
> | ---------- | ------------- | ----------------------- |
> | `names[0]` | 地址 $A$      | $\rightarrow$ 'A'       |
> | `names[1]` | 地址 $B$      | $\rightarrow$ 'B'       |
> | `names[2]` | 地址 $C$      | $\rightarrow$ 'C'       |

------



## 2. `char names[] = { "Alice", "Bob", "Charlie" };`



这是一种**错误的、非法的**声明。



### 📌 错误原因



- **类型不匹配：** 您声明 `names` 是一个 **`char` 数组**（即一维字符数组），但您尝试用多个**字符串字面量**（本质是 `char*` 类型）来初始化它。

- **编译器期望：** 编译器期望 `char names[]` 的初始化列表应该是一系列字符，例如：

  C

  ```
  char names[] = {'A', 'l', 'i', 'c', 'e', '\0'}; // 合法
  ```

- **初始化规则：** C/C++不允许使用多个字符串字面量来初始化一个简单的一维 `char` 数组。它无法确定如何将这三个独立的字符串序列化地放入一个简单的一维字符数组中。



### ✅ 正确的等价声明 (C/C++ 二维数组)



如果您想创建一个**可修改**的、包含多个字符串的二维数组，您需要显式地声明它为**二维数组**，并且指定列数（即最大字符串长度）：

C

```
// 这是一个包含 3 行，每行最多 8 个字符（包含 '\0'）的二维数组
char names_2d[3][8] = {
    "Alice",
    "Bob",
    "Charlie"
};
```



## 指针数组与双重下标索引

## 🎯 直接访问特定元素



继续使用您的示例结构：

C++

```
int row1[] = {1, 2, 3};
int row2[] = {4, 5};
int row3[] = {6, 7, 8, 9};

int* jagged_array[] = {
    row1, // 索引 0
    row2, // 索引 1
    row3  // 索引 2
};
```



### 💻 示例：访问 row2 中的元素 5



如果您想获取 `row2` 中的 `5`，它的位置是：

- **行索引:** $1$ (因为 `row2` 是 `jagged_array` 的第二个元素)
- **列索引:** $1$ (因为 $5$ 是 `row2` 的第二个元素)

您可以直接使用以下代码：

C++

```
#include <iostream>

// ... 结构定义同上 ...

int main() {
    // 假设 row1, row2, row3 和 jagged_array 已经定义

    // 访问 Row 1 (row2) 的索引 1 处的元素（即数值 5）
    int specific_value = jagged_array[1][1]; 

    std::cout << "特定元素 jagged_array[1][1] 的值是: " << specific_value << std::endl; 
    // 输出: 5

    // 访问 Row 2 (row3) 的索引 3 处的元素（即数值 9）
    int another_value = jagged_array[2][3];
    std::cout << "特定元素 jagged_array[2][3] 的值是: " << another_value << std::endl; 
    // 输出: 9

    return 0;
}
```



### ⚙️ 访问机制解释（无循环）



当您写 `jagged_array[i][j]` 时，编译器执行了以下操作：

1. **`jagged_array[i]`：** 编译器访问 `jagged_array` 数组的第 $i$ 个元素。这个元素是一个 `int*` 指针，它存储了第 $i$ 行（例如 `row2`）的起始地址。
2. **`[j]`：** 对这个得到的 `int*` 指针执行偏移操作，移动 $j$ 个 `int` 的距离，然后进行解引用，直接取出该位置的数值。



## 指向指针的指针（多级间接寻址）

## 🎯 1. 概念与定义



指向指针的指针是一种**指针变量**，但它存储的不是普通变量的地址，而是另一个**指针变量的地址**。



### 语法结构



使用两个星号（`**`）来声明指向指针的指针：

C++

```
Type** ptr_to_ptr;
```

- `Type`：最终指向的数据类型。
- `*`：第一个星号，表示这是一个**指针**（指向某物）。
- `**`：第二个星号，表示它指向的“某物”也是一个**指针**。



### 💻 内存结构示例



我们使用一个具体的例子来说明三级存储关系：

| **变量** | **类型** | **存储内容**       | **含义**           |
| -------- | -------- | ------------------ | ------------------ |
| `num`    | `int`    | `10`               | 存储最终数据（值） |
| `ptr`    | `int*`   | `&num` (num的地址) | 存储 `num` 的地址  |
| `pptr`   | `int**`  | `&ptr` (ptr的地址) | 存储 `ptr` 的地址  |

C++

```
int num = 10;
int *ptr = &num;      // 一级指针：ptr 存储 num 的地址
int **pptr = &ptr;    // 二级指针：pptr 存储 ptr 的地址

// 假设地址如下（仅为示例）：
// num:    0x1000  (存储 10)
// ptr:    0x2000  (存储 0x1000)
// pptr:   0x3000  (存储 0x2000)
```

------



## 2. 多级解引用 (Dereferencing)



要通过二级指针访问最终数据，您需要执行两次解引用操作：



### 📌 访问步骤



1. **一级解引用 (`\*pptr`)：**
   - 读取 `pptr` 存储的值（即 `ptr` 的地址 `0x2000`）。
   - 访问该地址，得到 `ptr` 变量本身存储的值（即 `num` 的地址 `0x1000`）。
   - **结果：** 得到一级指针 `ptr`。
2. **二级解引用 (`\**pptr`)：**
   - 对 `*pptr` 得到的一级指针再次解引用。
   - 访问 `0x1000` 地址，得到最终数据 `10`。
   - **结果：** 得到最终值 `num`。



### 💻 解引用示例



C++

```
int **pptr = &ptr;

std::cout << "值 num: " << num << std::endl;

// 访问 ptr 的值 (即 num 的地址)
std::cout << "ptr 的值 (num的地址): " << *pptr << std::endl; 
// 结果类似于: 0x1000

// 访问 num 的值 (最终的数据)
std::cout << "num 的值: " << **pptr << std::endl; 
// 结果是: 10
```

------



## 3. 主要用途和优势





### 用途一：在函数中修改指针本身（重要）



当您想在函数内部修改**调用者提供的指针变量**时，必须将该指针的地址传入，即使用二级指针。

- **场景：** 动态内存分配函数（如实现自己的 `malloc`）或在函数中重新指向一个新对象。

C++

```
void allocate_memory(int **ptr_to_ptr) {
    // *ptr_to_ptr 拿到的是 main 函数中那个 "p" 指针变量本身
    // 成功修改了 main 函数中 p 的值，使其指向新的堆内存
    *ptr_to_ptr = new int(42); 
}

int main() {
    int *p = nullptr;
    allocate_memory(&p); // 传入 p 的地址 (int**)
    std::cout << *p << std::endl; // 输出 42
    delete p;
    return 0;
}
```



### 用途二：动态创建二维数组



二级指针是实现C/C++中**真正动态二维数组**的基础，因为它允许您创建**不连续**的行。

C++

```
int rows = 3;
int cols = 4;

// 1. 创建一个包含 'rows' 个指针的数组 (int**)。
//    这就是我们的二级指针。
int **dynamic_array = new int*[rows]; 

// 2. 为每一行分配实际的内存空间
for (int i = 0; i < rows; ++i) {
    dynamic_array[i] = new int[cols]; 
}

// 访问：dynamic_array[i][j]
// 释放：需要双重循环释放内存
```



### 用途三：处理指针数组（如 `char**`）



指向指针的指针可以用来指向一个**指针数组**的首元素。

C++

```cpp
char *names[] = {"Alice", "Bob"};
char **ptr_to_names = names; // names 数组名退化为 char**
// 可以通过 ptr_to_names[0] 或 **ptr_to_names 访问 "Alice"
```



## 疑问

## 1. 指向指针的指针是否可以只有一个 `*`？



**答案：** **可以，但它不再是二级指针，而是一级指针。**

如果声明时只有一个 `*`：

C++

```
int *p;
// p 是一个一级指针，它只能存储 int 变量的地址。
```



### 为什么会出错？



当您尝试用一级指针去存储另一个指针的地址时，就会发生**类型不匹配**的错误：

C++

```
int num = 10;
int *ptr_a = &num;   // ptr_a 是 int* 类型
int *ptr_b = &ptr_a; // ❌ 错误：类型不匹配！
// 编译器会报错，因为 ptr_b (int*) 期望存储 int 的地址，
// 但你给了它 ptr_a (int*) 的地址 (即 int**)。
```



### 实际初始化时存储的是什么？



如果代码中**没有**这种类型错误，那么一个一级指针 `int *p` 在初始化时存储的应该是：

1. **一个 `int` 变量的地址：** `int *p = &some_int_variable;`
2. **`nullptr` (空指针)：** `int *p = nullptr;`
3. **动态分配的内存地址：** `int *p = new int;`
4. **另一个同类型指针的值：** `int *p = q;`

------



## 2. 取地址与解引用有没有运算顺序与运算优先级？



**答案：** **有，`&` (取地址) 和 `\*` (解引用) 都是一元运算符，它们的优先级和结合性决定了它们的运算顺序。**



### 运算优先级与结合性



| **运算符**   | **类型** | **优先级** | **结合性** | **解释** |
| ------------ | -------- | ---------- | ---------- | -------- |
| `*` (解引用) | 一元     | 3 (高)     | 右结合性   |          |
| `&` (取地址) | 一元     | 3 (高)     | 右结合性   |          |

**结论：** 由于 `*` 和 `&` 优先级相同，并且都是**右结合性**，它们的运算顺序是从右向左。



### 💻 实际运算示例



1. **结合性示例 (`\*&`)：**

   C++

   ```
   int x = 10;
   int *p = &x;
   
   // *&x 等价于 *(&x)
   // 1. 从右向左：(&x) 得到 x 的地址 (int*)
   // 2. 然后：* (int*) 解引用，得到 x 的值
   int val = *&x; // val = 10
   ```

   实际上，`*` 和 `&` 在这里是**互逆操作**，彼此抵消。

2. **与点运算符的优先级：**

   C++

   ```
   struct Data { int value; };
   Data d = {10};
   Data *ptr_d = &d;
   
   // (*ptr_d).value;
   // 点运算符(.) 的优先级高于 *，所以必须加括号！
   // 否则会先执行 ptr_d.value (无效操作)，然后解引用结果。
   // 为了避免这种优先级问题，C++提供了 -> 运算符。
   int v = ptr_d->value; // 推荐写法
   ```

------



## 3. `int **dynamic_array = new int*[rows];` 中 `rows` 可以为变量吗？



**答案：** **可以，`rows` 可以是变量。**

这是C++中动态内存分配（使用 `new`）的核心优势。

C++

```
#include <iostream>

int main() {
    int rows;
    std::cout << "请输入行数: ";
    std::cin >> rows; // rows 是一个变量

    // 动态分配一个包含 'rows' 个 int* 指针的数组
    int **dynamic_array = new int*[rows]; 
    
    // ... 后续代码可以正常使用 rows 来分配列 ...
    
    // 记得释放内存
    delete[] dynamic_array;
    return 0;
}
```



### 动态分配与静态数组的区别



| **特点**      | **动态分配 (new int\*[rows])**                   | **静态数组 (int arr[ROWS])**                      |
| ------------- | ------------------------------------------------ | ------------------------------------------------- |
| **大小**      | 必须在**运行时**确定。                           | 必须在**编译时**确定 (`ROWS` 必须是常量)。        |
| **内存位置**  | 分配在**堆（Heap）上。                           | 分配在栈（Stack）或全局/静态区**。                |
| **生命周期**  | 从 `new` 开始到 `delete` 结束，由程序员控制。    | 随函数结束或程序退出而自动销毁。                  |
| **指针/数组** | `dynamic_array` 是一个**指针** (`int**`)。       | `arr` 是一个数组，在表达式中退化为指针 (`int*`)。 |
| **内存管理**  | **必须**手动使用 `delete[]` 释放，否则内存泄漏。 | 自动管理，无需手动释放。                          |

**关键区别：** 这种动态分配的强大之处在于，它允许程序根据用户的输入或运行时的需求来确定数组的大小，从而有效地利用内存资源。



